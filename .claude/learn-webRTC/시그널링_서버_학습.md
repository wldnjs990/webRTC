# 시그널링 서버 학습 자료

> 작성일: 2025-12-31
> 대상: 주니어 개발자 (Django 경험자)
> 목적: Node.js + Express + Socket.io 시그널링 서버 완벽 이해

---

## 목차

1. [Express 프레임워크 이해](#1-express-프레임워크-이해)
2. [미들웨어 개념](#2-미들웨어-개념)
3. [시그널링 서버 구조](#3-시그널링-서버-구조)
4. [메인 서버 연동 플로우](#4-메인-서버-연동-플로우)
5. [실전 고려사항](#5-실전-고려사항)

---

## 1. Express 프레임워크 이해

### 1.1 Express란?

**Express = Node.js 웹 프레임워크 (Django와 유사)**

```javascript
// Django (Python)  ←→  Express (Node.js)
// 둘 다 웹 프레임워크
// 둘 다 HTTP 서버 기능 제공
// 둘 다 라우팅, 미들웨어 등 제공
```

### 1.2 바닐라 Node.js vs Express

```javascript
// ❌ 바닐라 Node.js (http 모듈만)
const http = require('http');

const server = http.createServer((req, res) => {
  // URL 파싱 직접
  if (req.url === '/health' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok' }));
  }
  // 불편: URL 파싱, JSON 파싱, CORS 모두 직접 구현
});

// ✅ Express 사용
const express = require('express');
const app = express();

app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

// 편리: 라우팅, JSON 자동 파싱, CORS 쉬움
```

### 1.3 Django vs Express 비교

| 항목 | Django | Express |
|------|--------|---------|
| **타입** | Full-stack 프레임워크 | 미니멀 프레임워크 |
| **철학** | "Batteries included" | "미니멀, 유연함" |
| **라우팅** | urls.py + views.py | routes/ + controllers/ |
| **ORM** | 내장 (Django ORM) | 별도 설치 (Mongoose) |
| **인증** | 내장 | 별도 설치 (Passport, JWT) |
| **구조** | **강제** (MVT 패턴) | **자유** (개발자 선택) |

### 1.4 패키지 매니저

**Express는 패키지 매니저와 무관**

```bash
# 모두 동일하게 작동
npm install express socket.io
yarn add express socket.io
pnpm add express socket.io
```

---

## 2. 미들웨어 개념

### 2.1 미들웨어란?

**요청과 응답 사이에서 실행되는 함수**

```javascript
요청 → 미들웨어1 → 미들웨어2 → 라우트 핸들러 → 응답
```

### 2.2 `app.use()` - Express 메서드

```javascript
const express = require('express');
const app = express();  // Express 인스턴스

app.use(...)  // ← Express가 제공하는 메서드 (Node.js 아님!)
app.get(...)  // ← Express 메서드
app.post(...) // ← Express 메서드
```

### 2.3 `express.json()` - JSON 파싱 미들웨어

**역할: 요청 본문(body)의 JSON을 파싱**

```javascript
// ❌ express.json() 없을 때
app.post('/api/rooms', (req, res) => {
  console.log(req.body);  // undefined
});

// ✅ express.json() 있을 때
app.use(express.json());

app.post('/api/rooms', (req, res) => {
  console.log(req.body);  // { roomName: 'Study Room', maxUsers: 10 }
  const { roomName, maxUsers } = req.body;  // 사용 가능!
});
```

**왜 자동 파싱이 아닌가?**

```javascript
// HTTP 요청 본문의 다양한 형식
1. JSON         (Content-Type: application/json)
2. URL-encoded  (Content-Type: application/x-www-form-urlencoded)
3. Multipart    (Content-Type: multipart/form-data) - 파일 업로드
4. Plain text
5. XML
6. Binary

// Express는 어떤 형식이 올지 모름
// → 개발자가 명시적으로 선택
app.use(express.json());           // JSON 파싱
app.use(express.urlencoded());     // 폼 데이터 파싱
app.use(multer().single('file'));  // 파일 업로드
```

### 2.4 미들웨어 적용 범위

```javascript
// 레벨 1: 전역 (모든 요청)
app.use(express.json());

// 레벨 2: 특정 경로 그룹
app.use('/api', apiLimiter);  // /api/* 전체

// 레벨 3: 라우터 전체
router.use(authMiddleware);   // 이 라우터의 모든 경로

// 레벨 4: 특정 라우트만
router.get('/', authMiddleware, handler);  // 이 경로만
```

### 2.5 Django와 비교

**Django: 앱별 미들웨어 불가능**

```python
# Django settings.py
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # ← 모든 앱에 적용됨 (앱별 적용 불가능)
]

# users/views.py
@login_required  # ← 뷰마다 개별 적용
def user_list(request):
    pass
```

**Express: 앱별 미들웨어 가능**

```javascript
// userRoutes.js
router.use(authMiddleware);  // ← 이 라우터 전체에 적용

router.get('/', ...);   // 모두 인증 필요
router.get('/:id', ...); // 모두 인증 필요

// roomRoutes.js
// 미들웨어 없음 → 모두 인증 불필요
router.get('/', ...);
```

---

## 3. 시그널링 서버 구조

### 3.1 현재 구조 (데모용)

```javascript
// backend/server.js
const express = require('express');
const http = require('http');
const socketIO = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIO(server, {
  cors: {
    origin: process.env.CLIENT_URL || 'http://localhost:5173',
    methods: ['GET', 'POST'],
    credentials: true
  }
});

// 방 관리 (메모리)
const rooms = new Map();

// 미들웨어
app.use(express.json());

// REST API 엔드포인트
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    activeConnections: io.engine.clientsCount,
    activeRooms: rooms.size
  });
});

// Socket.io 이벤트
io.on('connection', (socket) => {
  socket.on('create-room', (roomId, callback) => {
    rooms.set(roomId, { users: new Set() });
  });

  socket.on('offer', (data) => {
    socket.to(data.target).emit('offer', data);
  });

  socket.on('answer', (data) => {
    socket.to(data.target).emit('answer', data);
  });

  socket.on('ice-candidate', (data) => {
    socket.to(data.target).emit('ice-candidate', data);
  });
});

server.listen(3000);
```

### 3.2 문제점과 원인

| 문제 | 원인 | 해결 |
|------|------|------|
| 서버 재시작하면 방 사라짐 | DB 없이 메모리만 사용 | PostgreSQL/MySQL 저장 |
| 사용자 정보 없음 | 로그인 기능 없음 | JWT 인증 + 메인 서버 연동 |
| 권한 관리 없음 | 로그인 + 권한 로직 없음 | JWT + 권한 체크 |
| 방 히스토리 없음 | DB 없음 | room_history 테이블 |
| 통계/분석 불가능 | DB 없음 | analytics_events 테이블 |

**근본 원인:**
1. DB 없음 (영구 저장 불가)
2. 로그인/인증 없음 (사용자 식별 불가)

---

## 4. 메인 서버 연동 플로우

### 4.1 전체 아키텍처

```
┌─────────────────┐
│   프론트엔드     │
│   (React)       │
└────┬────────┬───┘
     │        │
     │ HTTP   │ WebSocket
     │        │
┌────▼────┐ ┌─▼──────────────┐
│ 메인    │ │ 시그널링        │
│ 서버    │◄┤ 서버            │
│         │ │                │
│ Django/ │ │ Node.js +      │
│ Spring  │ │ Socket.io      │
│         │ │                │
│ - 회원  │ │ - Offer/Answer │
│ - 인증  │ │ - ICE 교환     │
│ - 방CRUD│ │ - 실시간 중계  │
└────┬────┘ └────────────────┘
     │
     ▼
┌─────────────────┐
│  PostgreSQL     │
│  - users        │
│  - rooms        │
│  - room_history │
└─────────────────┘
```

### 4.2 플로우 1: 로그인

```
프론트엔드                메인 서버
    │                        │
    ├─── POST /api/auth/login ──→│
    │    {                   │
    │      email: "user@..", │
    │      password: "..."   │
    │    }                   │
    │                        │
    │                   [DB 조회]
    │                   [JWT 생성]
    │                        │
    │←── 200 OK ──────────────┤
    │    {                   │
    │      token: "eyJhbG...",
    │      user: {           │
    │        id: 123,        │
    │        username: "홍길동"
    │      }                 │
    │    }                   │
```

**메인 서버 코드 (Django):**

```python
# main_server/users/views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import authenticate

@api_view(['POST'])
def login(request):
    email = request.data.get('email')
    password = request.data.get('password')

    user = authenticate(username=email, password=password)

    if user:
        refresh = RefreshToken.for_user(user)
        return Response({
            'token': str(refresh.access_token),
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email
            }
        })

    return Response({'error': '인증 실패'}, status=401)
```

**프론트엔드 코드:**

```typescript
// frontend/src/services/auth.ts
async function login(email: string, password: string) {
  const response = await fetch('http://localhost:8000/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password })
  });

  const data = await response.json();

  // JWT 저장
  localStorage.setItem('token', data.token);
  localStorage.setItem('user', JSON.stringify(data.user));

  return data;
}
```

### 4.3 플로우 2: 방 생성

**2-1. 메인 서버에 방 생성 (DB 저장)**

```
프론트엔드                메인 서버
    │                        │
    ├─── POST /api/rooms ────→│
    │    Authorization:       │
    │    Bearer eyJhbG...     │
    │    {                    │
    │      name: "스터디룸",  │
    │      maxUsers: 4        │
    │    }                    │
    │                         │
    │                   [JWT 검증]
    │                   [DB 저장]
    │                         │
    │←── 201 Created ─────────┤
    │    {                    │
    │      id: "room-uuid-123",
    │      name: "스터디룸",  │
    │      ownerId: 123       │
    │    }                    │
```

**메인 서버 코드:**

```python
# main_server/rooms/views.py
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from .models import Room
import uuid

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_room(request):
    room = Room.objects.create(
        id=str(uuid.uuid4()),
        name=request.data.get('name'),
        owner_id=request.user.id,
        max_users=request.data.get('maxUsers', 10),
        status='active'
    )

    return Response({
        'id': room.id,
        'name': room.name,
        'ownerId': room.owner_id,
        'status': room.status
    }, status=201)
```

**2-2. 시그널링 서버에 방 생성 (실시간)**

```
프론트엔드                시그널링 서버
    │                          │
    ├─── connect (WebSocket) ──→│
    │    auth: {               │
    │      token: "eyJhbG..."  │
    │    }                     │
    │                          │
    │                     [JWT 검증]
    │                     [메인 서버 API 호출]
    │                          │
    │←── connected ─────────────┤
    │                          │
    ├─── emit('create-room') ──→│
    │    { roomId: "..." }     │
    │                          │
    │                  [메모리에 저장]
    │                          │
    │←── room-created ──────────┤
```

**시그널링 서버 코드 (JWT 인증 추가):**

```javascript
// backend/server.js
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');

// JWT 검증 미들웨어
io.use(async (socket, next) => {
  try {
    const token = socket.handshake.auth.token;

    if (!token) {
      return next(new Error('토큰 없음'));
    }

    // 메인 서버 API 호출로 검증
    const response = await fetch('http://localhost:8000/api/auth/verify', {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (!response.ok) {
      return next(new Error('인증 실패'));
    }

    const user = await response.json();

    // 소켓에 사용자 정보 저장
    socket.userId = user.id;
    socket.username = user.username;
    socket.email = user.email;
    socket.token = token;

    next();

  } catch (error) {
    next(new Error('인증 실패'));
  }
});

io.on("connection", (socket) => {
  console.log(`${socket.username} (ID: ${socket.userId}) 연결됨`);

  socket.on("create-room", async (roomId, callback) => {
    try {
      // 메인 서버에서 방 정보 확인
      const roomResponse = await fetch(`http://localhost:8000/api/rooms/${roomId}`, {
        headers: {
          'Authorization': `Bearer ${socket.token}`
        }
      });

      if (!roomResponse.ok) {
        throw new Error('방 정보를 찾을 수 없습니다');
      }

      const roomData = await roomResponse.json();

      // 소유자 확인
      if (roomData.ownerId !== socket.userId) {
        throw new Error('방 생성 권한이 없습니다');
      }

      // 시그널링 서버 메모리에 저장
      rooms.set(roomId, {
        id: roomId,
        name: roomData.name,
        ownerId: socket.userId,
        ownerName: socket.username,
        users: new Set()
      });

      socket.join(roomId);
      socket.currentRoom = roomId;

      callback({ success: true, roomId });

    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });
});
```

**프론트엔드 전체 플로우:**

```typescript
// 방 생성 플로우
async function createAndJoinRoom(roomName: string) {
  // 1. 메인 서버에 방 생성 (DB 저장)
  const response = await fetch('http://localhost:8000/api/rooms', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    },
    body: JSON.stringify({
      name: roomName,
      maxUsers: 4
    })
  });

  const roomData = await response.json();

  // 2. 시그널링 서버에 방 생성 (실시간 통신용)
  socket.emit('create-room', roomData.id, (result) => {
    if (result.success) {
      console.log('방 생성 완료:', result.roomId);
    }
  });
}
```

### 4.4 플로우 3: 방 종료 및 동기화

```
사용자                시그널링 서버              메인 서버
  │                        │                        │
  ├─── disconnect ────────→│                        │
  │                        │                        │
  │                   [마지막 사용자]               │
  │                   [메모리 삭제]                 │
  │                        │                        │
  │                        ├─ PATCH /api/rooms/123 →│
  │                        │  {                     │
  │                        │    status: "closed",   │
  │                        │    endedAt: "..."     │
  │                        │  }                     │
  │                        │                        │
  │                        │                   [DB 업데이트]
  │                        │←─ 200 OK ──────────────┤
```

**시그널링 서버 코드:**

```javascript
// 방 나가기 공통 로직 (수정)
async function leaveCurrentRoom(socket) {
  if (socket.currentRoom) {
    const room = rooms.get(socket.currentRoom);

    if (room) {
      room.users.delete(socket.id);

      socket.to(socket.currentRoom).emit("user-left", {
        userId: socket.id,
        username: socket.username
      });

      // 방이 비었으면
      if (room.users.size === 0) {
        // 1. 메모리에서 삭제
        rooms.delete(socket.currentRoom);

        // 2. 메인 서버 DB 업데이트
        try {
          await fetch(`http://localhost:8000/api/rooms/${socket.currentRoom}`, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${socket.token}`
            },
            body: JSON.stringify({
              status: 'closed',
              endedAt: new Date().toISOString()
            })
          });

          console.log('[DB 업데이트] 방 종료 기록됨');
        } catch (error) {
          console.error('[에러] DB 업데이트 실패:', error);
        }
      }
    }

    socket.leave(socket.currentRoom);
    socket.currentRoom = null;
  }
}
```

### 4.5 전체 플로우 요약

**1. 초기 설정 (한 번)**

```
1. 사용자 로그인 (메인 서버)
   → JWT 받기
   → 로컬 저장

2. 시그널링 서버 연결
   → JWT 전달
   → 인증 완료
```

**2. 방 생성 (이중 저장)**

```
1. 메인 서버에 방 생성
   → DB 저장 (영구)
   → 방 ID 받기

2. 시그널링 서버에 방 생성
   → 메모리 저장 (빠른 접근)
   → 실시간 통신 준비
```

**3. WebRTC 통신 (시그널링 서버만)**

```
Offer/Answer/ICE 교환
→ 시그널링 서버가 중계
→ P2P 연결 성립
→ 비디오/오디오 직접 전송
```

**4. 방 종료 (동기화)**

```
마지막 사용자 퇴장
→ 시그널링 서버 메모리 삭제
→ 메인 서버 DB 업데이트 (status: closed)
```

---

## 5. 실전 고려사항

### 5.1 보안

```javascript
// JWT 인증
io.use(async (socket, next) => {
  const token = socket.handshake.auth.token;
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  socket.userId = decoded.userId;
  next();
});

// Rate Limiting
const connectionLimiter = new Map();

io.on("connection", (socket) => {
  const userConnections = connectionLimiter.get(socket.userId) || 0;

  if (userConnections >= 5) {
    socket.disconnect();
    return;
  }

  connectionLimiter.set(socket.userId, userConnections + 1);
});
```

### 5.2 확장성 (Redis)

```javascript
// 다중 시그널링 서버 동기화
const redis = require('redis');
const redisClient = redis.createClient();

// 방 정보를 Redis에 저장 (서버 간 공유)
socket.on("create-room", async (roomId) => {
  await redisClient.set(`room:${roomId}`, JSON.stringify({
    id: roomId,
    ownerId: socket.userId
  }));
});
```

### 5.3 모니터링/로깅

```javascript
// 통계 수집
socket.on("offer", async (data) => {
  // 시그널링 수행
  socket.to(data.target).emit("offer", data);

  // 메인 서버에 통계 전송
  await fetch('http://localhost:8000/api/analytics/events', {
    method: 'POST',
    body: JSON.stringify({
      eventType: 'offer_sent',
      userId: socket.userId,
      roomId: socket.currentRoom
    })
  });
});
```

### 5.4 데이터베이스 스키마

```sql
-- 사용자
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(100),
  email VARCHAR(255) UNIQUE,
  password_hash VARCHAR(255),
  created_at TIMESTAMP DEFAULT NOW()
);

-- 방
CREATE TABLE rooms (
  id VARCHAR(255) PRIMARY KEY,
  name VARCHAR(100),
  owner_id INTEGER REFERENCES users(id),
  max_users INTEGER DEFAULT 10,
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  ended_at TIMESTAMP
);

-- 방 참여자
CREATE TABLE room_participants (
  id SERIAL PRIMARY KEY,
  room_id VARCHAR(255) REFERENCES rooms(id),
  user_id INTEGER REFERENCES users(id),
  joined_at TIMESTAMP DEFAULT NOW(),
  left_at TIMESTAMP
);

-- 통계
CREATE TABLE analytics_events (
  id SERIAL PRIMARY KEY,
  event_type VARCHAR(50),
  user_id INTEGER REFERENCES users(id),
  room_id VARCHAR(255),
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);
```

---

## 6. 실행 및 테스트

### 6.1 설치

```bash
# 시그널링 서버
cd backend
pnpm add node-fetch jsonwebtoken

# 프론트엔드
cd frontend
pnpm add socket.io-client
```

### 6.2 실행 순서

```bash
# 1. 메인 서버 (Django)
cd main_server
python manage.py runserver 8000

# 2. 시그널링 서버
cd backend
pnpm dev

# 3. 프론트엔드
cd frontend
pnpm dev
```

---

## 7. 핵심 정리

### Express vs Django

- Express = 미니멀 프레임워크 (필요한 것만 추가)
- Django = Full-stack 프레임워크 (많은 기능 내장)

### 미들웨어

- `app.use()` = Express 메서드
- 전역/라우터별/경로별 적용 가능
- Django보다 유연함

### 시그널링 서버 역할

- Offer/Answer/ICE 중계만
- P2P 연결 후에는 관여 안 함
- 메인 서버와 연동 필수 (인증, DB)

### 데이터 흐름

1. 로그인: 메인 서버 → JWT
2. 방 생성: 메인 서버 (DB) + 시그널링 서버 (메모리)
3. WebRTC: 시그널링 서버 중계 → P2P 직접
4. 종료: 시그널링 메모리 삭제 → 메인 DB 업데이트

---

## 8. 다음 학습 계획

1. ✅ Express 기본 이해
2. ✅ 미들웨어 개념
3. ✅ 시그널링 서버 구조
4. ✅ 메인 서버 연동 플로우
5. ⬜ 프론트엔드 WebRTC 구현
6. ⬜ 실전 프로젝트 완성
