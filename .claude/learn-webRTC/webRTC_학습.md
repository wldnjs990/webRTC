# **WebRTC ì™„ë²½ ê°€ì´ë“œ - ì£¼ë‹ˆì–´ ê°œë°œìë¥¼ ìœ„í•œ í•™ìŠµ ìë£Œ**

> ì‘ì„±ì¼: 2025-12-31 ëŒ€ìƒ: ì£¼ë‹ˆì–´ ê°œë°œì ëª©ì : WebRTCì˜ ê°œë…ë¶€í„° ì‹¤ì „ êµ¬í˜„ê¹Œì§€ ì™„ë²½ ì´í•´
> 

---

## **ğŸ“š ëª©ì°¨**

1. [WebRTCë€ ë¬´ì—‡ì¸ê°€?](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#1-webrtc%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)
2. [WebRTC vs ë‹¤ë¥¸ í†µì‹  ê¸°ìˆ ](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#2-webrtc-vs-%EB%8B%A4%EB%A5%B8-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0)
3. [WebRTCì˜ í•µì‹¬ ê°œë…](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#3-webrtc%EC%9D%98-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90)
4. [í•„ìš”í•œ ì„œë²„ë“¤](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%84%9C%EB%B2%84%EB%93%A4)
5. [ë°”ë‹ë¼ JavaScriptë¡œ êµ¬í˜„í•˜ê¸°](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#5-%EB%B0%94%EB%8B%90%EB%9D%BC-javascript%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)
6. [ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©í•˜ê¸°](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#6-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)
7. [ì‹¤ì „ ì˜ˆì œ: í‘œì • ì±Œë¦°ì§€ ê²Œì„](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#7-%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C-%ED%91%9C%EC%A0%95-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EA%B2%8C%EC%9E%84)
8. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#8-%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85)
9. [ì²´í¬ë¦¬ìŠ¤íŠ¸](https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/user/Desktop/WebRTC_Learning/WebRTC_%EC%99%84%EB%B2%BD_%EA%B0%80%EC%9D%B4%EB%93%9C.md#9-%EC%B2%B4%ED%81%AC%EB%A6%AC%EC%8A%A4%ED%8A%B8)

---

## **1. WebRTCë€ ë¬´ì—‡ì¸ê°€?**

### **1.1 ì •ì˜**

**WebRTC (Web Real-Time Communication)**

- ì›¹ ë¸Œë¼ìš°ì € ê°„Â **ì‹¤ì‹œê°„ í†µì‹ **ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ”Â **ì˜¤í”ˆì†ŒìŠ¤ ê¸°ìˆ **
- **ë³„ë„ í”ŒëŸ¬ê·¸ì¸ ì—†ì´**Â ë¸Œë¼ìš°ì €ë§Œìœ¼ë¡œ ë¹„ë””ì˜¤/ì˜¤ë””ì˜¤/ë°ì´í„° ì „ì†¡ ê°€ëŠ¥
- **P2P (Peer-to-Peer)**Â ë°©ì‹ìœ¼ë¡œ ì§ì ‘ ì—°ê²°

### **1.2 íŠ¹ì§•**

```
âœ… ë¸Œë¼ìš°ì € ë‚´ì¥ API (ì„¤ì¹˜ ë¶ˆí•„ìš”)
âœ… P2P ì§ì ‘ ì—°ê²° (ì„œë²„ ë¶€í•˜ ì ìŒ)
âœ… ë‚®ì€ ì§€ì—° ì‹œê°„ (ì‹¤ì‹œê°„ í†µì‹ )
âœ… ì•”í˜¸í™” ê¸°ë³¸ ì œê³µ (ë³´ì•ˆ)
âœ… ë¬´ë£Œ ì˜¤í”ˆì†ŒìŠ¤
```

### **1.3 ì£¼ìš” ì‚¬ìš©ì²˜**

```jsx
// í™”ìƒ íšŒì˜
Zoom, Google Meet, Microsoft Teams

// í™”ë©´ ê³µìœ 
Discord, Slack í†µí™”

// ì˜¨ë¼ì¸ ê²Œì„
ì‹¤ì‹œê°„ ë©€í‹°í”Œë ˆì´ì–´

// íŒŒì¼ ê³µìœ 
P2P íŒŒì¼ ì „ì†¡

// IoT/ìŠ¤íŠ¸ë¦¬ë°
ë³´ì•ˆ ì¹´ë©”ë¼, ë¼ì´ë¸Œ ë°©ì†¡

```

---

## **2. WebRTC vs ë‹¤ë¥¸ í†µì‹  ê¸°ìˆ **

### **2.1 WebSocketê³¼ì˜ ì°¨ì´**

| êµ¬ë¶„ | WebSocket | WebRTC |
| --- | --- | --- |
| **ì—°ê²° ë°©ì‹** | í´ë¼ì´ì–¸íŠ¸ â†” ì„œë²„ | í´ë¼ì´ì–¸íŠ¸ â†” í´ë¼ì´ì–¸íŠ¸ (P2P) |
| **ë°ì´í„° íë¦„** | ëª¨ë“  ë°ì´í„°ê°€ ì„œë²„ë¥¼ ê±°ì¹¨ | ì§ì ‘ ì „ì†¡ (ì„œë²„ ì•ˆ ê±°ì¹¨) |
| **ìš©ë„** | ì±„íŒ…, ê²Œì„ ëª…ë ¹ì–´, ì•Œë¦¼ | ë¹„ë””ì˜¤, ì˜¤ë””ì˜¤, ëŒ€ìš©ëŸ‰ ë°ì´í„° |
| **ì„œë²„ ë¶€í•˜** | ë†’ìŒ (ëª¨ë“  ë©”ì‹œì§€ ì¤‘ê³„) | ë‚®ìŒ (ì—°ê²°ë§Œ ë„ì™€ì¤Œ) |
| **ì§€ì—° ì‹œê°„** | ì¤‘ê°„ (~50-200ms) | ë‚®ìŒ (~10-50ms) |

### **WebSocket ì˜ˆì‹œ**

```jsx
// ëª¨ë“  ë©”ì‹œì§€ê°€ ì„œë²„ë¥¼ ê±°ì¹¨
Alice â†’ WebSocket ì„œë²„ â†’ Bob
      (ì„œë²„ê°€ ì¤‘ê³„)

// ì„œë²„ ë¶€í•˜ ì¦ê°€
100ëª… ì±„íŒ… = ì„œë²„ê°€ ëª¨ë“  ë©”ì‹œì§€ ì¤‘ê³„

```

### **WebRTC ì˜ˆì‹œ**

```jsx
// ì§ì ‘ ì—°ê²°
Alice â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Bob
   (ì„œë²„ ì•ˆ ê±°ì¹¨)

// ì„œë²„ ë¶€í•˜ ë‚®ìŒ
100ëª… í™”ìƒ = ì„œë²„ëŠ” ì´ˆê¸° ì—°ê²°ë§Œ ë„ì™€ì¤Œ

```

### **2.2 HTTP/REST APIì™€ì˜ ì°¨ì´**

```
HTTP/REST API:
- ìš”ì²­ â†’ ì‘ë‹µ (ë‹¨ë°©í–¥)
- ì‹¤ì‹œê°„ ì•„ë‹˜
- ì„œë²„ ì¤‘ì‹¬

WebRTC:
- ì–‘ë°©í–¥ ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë°
- P2P ì§ì ‘ ì—°ê²°
- í´ë¼ì´ì–¸íŠ¸ ì¤‘ì‹¬

```

### **2.3 ì–¸ì œ ë¬´ì—‡ì„ ì‚¬ìš©í•´ì•¼ í•˜ë‚˜?**

```jsx
âœ… WebSocket ì‚¬ìš©:
- ì±„íŒ… ë©”ì‹œì§€
- ê²Œì„ ëª…ë ¹ì–´
- ì‹¤ì‹œê°„ ì•Œë¦¼
- ì£¼ì‹ ì‹œì„¸
- ê²Œì„ ìƒíƒœ ë™ê¸°í™”

âœ… WebRTC ì‚¬ìš©:
- í™”ìƒ í†µí™”
- ìŒì„± í†µí™”
- í™”ë©´ ê³µìœ 
- ëŒ€ìš©ëŸ‰ íŒŒì¼ ì „ì†¡ (P2P)
- ì‹¤ì‹œê°„ ê²Œì„ (ë‚®ì€ ì§€ì—° í•„ìš”)

âœ… ë‘˜ ë‹¤ ì‚¬ìš©:
- í™”ìƒ íšŒì˜ ì•±
  â†’ WebRTC: ë¹„ë””ì˜¤/ì˜¤ë””ì˜¤
  â†’ WebSocket: ì±„íŒ…, ì°¸ì—¬ì ê´€ë¦¬

```

---

## **3. WebRTCì˜ í•µì‹¬ ê°œë…**

### **3.1 ì£¼ìš” êµ¬ì„± ìš”ì†Œ**

### **3.1.1 RTCPeerConnection (í•µì‹¬!)**

```jsx
// ë¸Œë¼ìš°ì € ë‚´ì¥ API (import ë¶ˆí•„ìš”)
const pc = new RTCPeerConnection({
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' }
  ]
});

// ì—­í• : P2P ì—°ê²° ê´€ë¦¬

```

**ì£¼ìš” ë©”ì„œë“œ:**

```jsx
// Offer/Answer ìƒì„±
await pc.createOffer()
await pc.createAnswer()

// Local/Remote Description ì„¤ì •
await pc.setLocalDescription(description)
await pc.setRemoteDescription(description)

// ICE Candidate ì¶”ê°€
await pc.addIceCandidate(candidate)

// ë¯¸ë””ì–´ íŠ¸ë™ ì¶”ê°€
pc.addTrack(track, stream)

// ì—°ê²° ì¢…ë£Œ
pc.close()

```

**ì£¼ìš” ì´ë²¤íŠ¸:**

```jsx
pc.onicecandidate = (event) => {
  // ICE Candidate ë°œê²¬ ì‹œ
}

pc.ontrack = (event) => {
  // ìƒëŒ€ë°© ìŠ¤íŠ¸ë¦¼ ë°›ì„ ì‹œ
}

pc.onconnectionstatechange = () => {
  // ì—°ê²° ìƒíƒœ ë³€ê²½ ì‹œ
}

pc.oniceconnectionstatechange = () => {
  // ICE ì—°ê²° ìƒíƒœ ë³€ê²½ ì‹œ
}

```

### **3.1.2 MediaStream**

```jsx
// ì›¹ìº /ë§ˆì´í¬ ì ‘ê·¼
const stream = await navigator.mediaDevices.getUserMedia({
  video: true,
  audio: true
});

// í™”ë©´ ê³µìœ 
const screenStream = await navigator.mediaDevices.getDisplayMedia({
  video: true
});

// íŠ¸ë™ ê´€ë¦¬
stream.getTracks()           // ëª¨ë“  íŠ¸ë™
stream.getVideoTracks()      // ë¹„ë””ì˜¤ íŠ¸ë™ë§Œ
stream.getAudioTracks()      // ì˜¤ë””ì˜¤ íŠ¸ë™ë§Œ
stream.addTrack(track)       // íŠ¸ë™ ì¶”ê°€
stream.removeTrack(track)    // íŠ¸ë™ ì œê±°

```

### **3.1.3 DataChannel**

```jsx
// P2P ë°ì´í„° ì „ì†¡ ì±„ë„
const dataChannel = pc.createDataChannel('chat');

// ë°ì´í„° ì „ì†¡
dataChannel.send('Hello!');

// ë°ì´í„° ìˆ˜ì‹ 
dataChannel.onmessage = (event) => {
  console.log('ë°›ì€ ë©”ì‹œì§€:', event.data);
};

// ìš©ë„: ì±„íŒ…, ê²Œì„ ëª…ë ¹ì–´, íŒŒì¼ ì „ì†¡ ë“±

```

### **3.2 ì—°ê²° ê³¼ì • (Signaling)**

### **3.2.1 SDP (Session Description Protocol)**

```
SDPë€?
- ì—°ê²° ì •ë³´ë¥¼ ë‹´ì€ í…ìŠ¤íŠ¸ í˜•ì‹
- ì½”ë±, í•´ìƒë„, ëŒ€ì—­í­ ë“±ì˜ ì •ë³´ í¬í•¨

```

**Offer (ì œì•ˆ):**

```jsx
// Aliceê°€ ìƒì„±
const offer = await pc.createOffer();
await pc.setLocalDescription(offer);

console.log(offer);
// {
//   type: "offer",
//   sdp: "v=0\r\no=- 123456789 2 IN IP4 127.0.0.1\r\n..."
// }

// Bobì—ê²Œ ì „ì†¡ (ì‹œê·¸ë„ë§ ì„œë²„ í†µí•´)
socket.emit('offer', offer);

```

**Answer (ì‘ë‹µ):**

```jsx
// Bobì´ ìƒì„±
await pc.setRemoteDescription(offer);  // Aliceì˜ offer ì„¤ì •
const answer = await pc.createAnswer();
await pc.setLocalDescription(answer);

console.log(answer);
// {
//   type: "answer",
//   sdp: "v=0\r\no=- 987654321 2 IN IP4 127.0.0.1\r\n..."
// }

// Aliceì—ê²Œ ì „ì†¡
socket.emit('answer', answer);

```

### **3.2.2 ICE (Interactive Connectivity Establishment)**

**ICEê°€ í•˜ëŠ” ì¼:**

```
1. ì—°ê²° ê°€ëŠ¥í•œ ëª¨ë“  ê²½ë¡œ(Candidate) ì°¾ê¸°
2. ê° ê²½ë¡œë¡œ ì—°ê²° ì‹œë„
3. ì„±ê³µí•œ ê²½ë¡œ ì¤‘ ìµœì ì˜ ê²ƒ ì„ íƒ

```

**3ê°€ì§€ Candidate íƒ€ì…:**

### **1) Host Candidate (ë¡œì»¬)**

```jsx
// ê°™ì€ ë„¤íŠ¸ì›Œí¬ (ê°™ì€ WiFi)
{
  type: 'host',
  address: '192.168.0.100',  // ì‚¬ì„¤ IP
  port: 54321,
  priority: 2130706431  // ê°€ì¥ ë†’ìŒ (ê°€ì¥ ë¹ ë¦„)
}

// ì‚¬ìš© ì˜ˆ: ì§‘/íšŒì‚¬ ë‚´ë¶€ì—ì„œ í…ŒìŠ¤íŠ¸

```

### **2) Server Reflexive Candidate (STUN)**

```jsx
// STUN ì„œë²„ê°€ ì•Œë ¤ì¤€ ê³µì¸ IP
{
  type: 'srflx',
  address: '123.45.67.89',  // ê³µì¸ IP
  port: 5000,
  relatedAddress: '192.168.0.100',  // ì›ë˜ ì‚¬ì„¤ IP
  priority: 1694498815  // ì¤‘ê°„
}

// ê°€ì¥ ì¼ë°˜ì  (80~90% ì—¬ê¸°ì„œ ì—°ê²°)

```

### **3) Relay Candidate (TURN)**

```jsx
// TURN ì„œë²„ë¥¼ í†µí•œ ì¤‘ê³„
{
  type: 'relay',
  address: '1.2.3.4',  // TURN ì„œë²„ IP
  port: 3478,
  relatedAddress: '123.45.67.89',
  priority: 16777215  // ê°€ì¥ ë‚®ìŒ (ëŠë¦¼)
}

// ë°©í™”ë²½ ìš°íšŒìš© (5~10%)

```

**ICE Candidate êµí™˜:**

```jsx
// Alice
pc.onicecandidate = (event) => {
  if (event.candidate) {
    console.log('ICE Candidate ë°œê²¬:', event.candidate.type);

    // Bobì—ê²Œ ì „ì†¡
    socket.emit('ice-candidate', event.candidate);
  } else {
    console.log('ëª¨ë“  ICE Candidate ìˆ˜ì§‘ ì™„ë£Œ');
  }
};

// Bob
socket.on('ice-candidate', async (candidate) => {
  await pc.addIceCandidate(candidate);
  console.log('Candidate ì¶”ê°€, ì—°ê²° ì‹œë„ ì¤‘...');
});

```

### **3.3 ì—°ê²° ìƒíƒœ (í‘œì¤€ ê°’)**

### **Connection State**

```jsx
pc.connectionState

// W3C í‘œì¤€ìœ¼ë¡œ ì •í•´ì§„ ê°’ (ë°±ì—”ë“œê°€ ì •í•˜ëŠ” ê²Œ ì•„ë‹˜!)
"new"           // ì´ˆê¸° ìƒíƒœ
"connecting"    // ì—°ê²° ì‹œë„ ì¤‘
"connected"     // ì—°ê²° ì„±ê³µ âœ…
"disconnected"  // ì—°ê²° ëŠê¹€ âš ï¸
"failed"        // ì—°ê²° ì‹¤íŒ¨ âŒ
"closed"        // ì—°ê²° ë‹«í˜

```

### **ICE Connection State**

```jsx
pc.iceConnectionState

// W3C í‘œì¤€ ê°’
"new"           // ì´ˆê¸°
"checking"      // ICE Candidate í™•ì¸ ì¤‘
"connected"     // ICE ì—°ê²° ì„±ê³µ (ì¼ë¶€ ê²½ë¡œ)
"completed"     // ICE ì—°ê²° ì™„ë£Œ (ëª¨ë“  ê²½ë¡œ)
"failed"        // ICE ì‹¤íŒ¨
"disconnected"  // ICE ëŠê¹€
"closed"        // ICE ë‹«í˜

```

### **Signaling State**

```jsx
pc.signalingState

// W3C í‘œì¤€ ê°’
"stable"                  // ì•ˆì • (Offer/Answer êµí™˜ ì™„ë£Œ)
"have-local-offer"        // ë¡œì»¬ Offer ìƒì„±ë¨
"have-remote-offer"       // ìƒëŒ€ë°© Offer ë°›ìŒ
"have-local-pranswer"     // ì„ì‹œ ë¡œì»¬ Answer
"have-remote-pranswer"    // ì„ì‹œ ì›ê²© Answer
"closed"                  // ë‹«í˜

```

### **3.4 ë°ì´í„° íë¦„ ì´í•´í•˜ê¸°**

### **ì‹œê·¸ë„ë§ ë‹¨ê³„ (ì´ˆê¸° í•œ ë²ˆ)**

```jsx
[ì‹œê·¸ë„ë§ ì„œë²„ ì‚¬ìš©]

Alice                    ì‹œê·¸ë„ë§ ì„œë²„                Bob
  â”‚                            â”‚                      â”‚
  â”œâ”€â”€â”€ Offer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                      â”‚
  â”‚                            â”œâ”€â”€â”€ Offer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚                            â”‚                      â”‚
  â”‚                            â”‚<â”€â”€â”€ Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚<â”€â”€â”€ Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                      â”‚
  â”‚                            â”‚                      â”‚
  â”œâ”€â”€â”€ ICE Candidate â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                      â”‚
  â”‚                            â”œâ”€â”€â”€ ICE Candidate â”€â”€â”€>â”‚
  â”‚                            â”‚                      â”‚

// ì´ ê³¼ì •ì—ì„œë§Œ ì„œë²„ ì‚¬ìš©!

```

### **P2P í†µì‹  ë‹¨ê³„ (ê³„ì†)**

```jsx
[ì„œë²„ ì—†ì´ ì§ì ‘ í†µì‹ ]

Alice â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Bob
      (ë¹„ë””ì˜¤, ì˜¤ë””ì˜¤, ë°ì´í„° ì§ì ‘ ì „ì†¡)

// ì‹¤ì‹œê°„ìœ¼ë¡œ ê³„ì† í†µì‹ :
- ë¹„ë””ì˜¤ í”„ë ˆì„: ì´ˆë‹¹ 30íšŒ
- ì˜¤ë””ì˜¤ ìƒ˜í”Œ: ì´ˆë‹¹ 50íšŒ
- RTCP (ìƒíƒœ ì²´í¬): 2~5ì´ˆë§ˆë‹¤

// ì„œë²„ëŠ” ì—°ê²° ìœ ì§€ì— ê´€ì—¬ ì•ˆ í•¨!
// ë‹¨, ì¬ì—°ê²° í•„ìš” ì‹œ ë‹¤ì‹œ ì‹œê·¸ë„ë§ ì„œë²„ ì‚¬ìš©

```

### **ì—°ê²° ëŠê¹€ ë° ì¬ì—°ê²°**

```jsx
[ë„¤íŠ¸ì›Œí¬ ëŠê¹€]
Alice Xâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€X Bob

// WebRTCê°€ ìë™ ê°ì§€ (RTCPë¡œ)
pc.connectionState = "disconnected"

[ì¬ì—°ê²° ì‹œë„]
// ìë™ ì¬ì‹œë„ (ICE Restart)
const offer = await pc.createOffer({ iceRestart: true });
await pc.setLocalDescription(offer);

// ì‹œê·¸ë„ë§ ì„œë²„ë¡œ ì¬í˜‘ìƒ
socket.emit('renegotiate', offer);

// IP ì¬í™•ì¸ + ìƒˆ ICE Candidate ìˆ˜ì§‘

```

---

## **4. í•„ìš”í•œ ì„œë²„ë“¤**

### **4.1 ì‹œê·¸ë„ë§ ì„œë²„ (í•„ìˆ˜!)**

### **ì—­í• **

```
âœ… Offer/Answer ì¤‘ê³„
âœ… ICE Candidate êµí™˜
âœ… ë°© ê´€ë¦¬
âœ… ì‚¬ìš©ì ì—°ê²°/í•´ì œ ê°ì§€

```

### **êµ¬ì¶• ë°©ë²•**

**Node.js + Socket.io (ì¶”ì²œ!)**

```jsx
// server.js
const express = require('express');
const app = express();
const server = require('http').Server(app);
const io = require('socket.io')(server, {
  cors: {
    origin: "http://localhost:5173",
    methods: ["GET", "POST"]
  }
});

const rooms = new Map();

io.on('connection', (socket) => {
  console.log('ìƒˆ ì‚¬ìš©ì ì—°ê²°:', socket.id);

  // ë°© ìƒì„±
  socket.on('create-room', (roomId) => {
    socket.join(roomId);
    rooms.set(roomId, new Set([socket.id]));
    socket.emit('room-created', roomId);
  });

  // ë°© ì…ì¥
  socket.on('join-room', (roomId) => {
    if (!rooms.has(roomId)) {
      socket.emit('error', 'Room not found');
      return;
    }

    socket.join(roomId);
    rooms.get(roomId).add(socket.id);

    // ê¸°ì¡´ ì°¸ì—¬ìë“¤ì—ê²Œ ì•Œë¦¼
    socket.to(roomId).emit('user-joined', socket.id);
  });

  // Offer ì¤‘ê³„
  socket.on('offer', (data) => {
    socket.to(data.target).emit('offer', {
      offer: data.offer,
      from: socket.id
    });
  });

  // Answer ì¤‘ê³„
  socket.on('answer', (data) => {
    socket.to(data.target).emit('answer', {
      answer: data.answer,
      from: socket.id
    });
  });

  // ICE Candidate ì¤‘ê³„
  socket.on('ice-candidate', (data) => {
    socket.to(data.target).emit('ice-candidate', {
      candidate: data.candidate,
      from: socket.id
    });
  });

  // ì—°ê²° í•´ì œ
  socket.on('disconnect', () => {
    rooms.forEach((users, roomId) => {
      if (users.has(socket.id)) {
        users.delete(socket.id);
        io.to(roomId).emit('user-left', socket.id);

        if (users.size === 0) {
          rooms.delete(roomId);
        }
      }
    });
  });
});

server.listen(3000, () => {
  console.log('ì‹œê·¸ë„ë§ ì„œë²„ ì‹¤í–‰: 3000ë²ˆ í¬íŠ¸');
});

```

**Django (Django Channels ì‚¬ìš©)**

```python
# consumers.py
import json
from channels.generic.websocket import AsyncWebsocketConsumer

class SignalingConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_name = self.scope['url_route']['kwargs']['room_name']
        self.room_group_name = f'webrtc_{self.room_name}'

        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        await self.accept()

    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

    async def receive(self, text_data):
        data = json.loads(text_data)

        # ë©”ì‹œì§€ íƒ€ì…ì— ë”°ë¼ ì²˜ë¦¬
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'webrtc_message',
                'message': data
            }
        )

    async def webrtc_message(self, event):
        await self.send(text_data=json.dumps(event['message']))

```

### **ë©”ì¸ ì„œë²„ì™€ì˜ ê´€ê³„**

```
ì˜µì…˜ 1: ë¶„ë¦¬ (ì¶”ì²œ)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Django/Springâ”‚  â† ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚ (ë©”ì¸ ì„œë²„)   â”‚     íšŒì›ê°€ì…, DB ë“±
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Node.js      â”‚  â† WebRTC ì‹œê·¸ë„ë§ë§Œ
â”‚ (ì‹œê·¸ë„ë§)    â”‚     ì‹¤ì‹œê°„ í†µì‹  ì „ë‹´
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ì¥ì : ê¸°ìˆ  ìŠ¤íƒ ìµœì í™”, ë…ë¦½ì  í™•ì¥

ì˜µì…˜ 2: í†µí•©
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Django       â”‚  â† ëª¨ë“  ê²ƒ
â”‚ + Channels   â”‚     REST API + WebSocket
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ì¥ì : ê´€ë¦¬ í¸í•¨, ì„œë²„ 1ê°œ

```

### **4.2 STUN ì„œë²„ (ê±°ì˜ í•„ìˆ˜)**

### **ì—­í• **

```
âœ… í´ë¼ì´ì–¸íŠ¸ì˜ ê³µì¸ IP ì£¼ì†Œ í™•ì¸
âœ… NAT íƒ€ì… í™•ì¸

```

### **ë¬´ë£Œ STUN ì„œë²„ ì‚¬ìš© (ì¶”ì²œ!)**

```jsx
const configuration = {
  iceServers: [
    // Google ë¬´ë£Œ STUN ì„œë²„
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },

    // Mozilla ë¬´ë£Œ STUN ì„œë²„
    { urls: 'stun:stun.services.mozilla.com' }
  ]
};

const pc = new RTCPeerConnection(configuration);

```

### **ì§ì ‘ êµ¬ì¶• (ë¹„ì¶”ì²œ)**

```bash
# coturn ì„¤ì¹˜ (Ubuntu)
sudo apt-get install coturn

# ì„¤ì •
sudo nano /etc/turnserver.conf

# ì´ìœ : ë¬´ë£Œë¡œ ì¶©ë¶„, ê´€ë¦¬ ë¶€ë‹´, ê¸€ë¡œë²Œ ë¶„ì‚° í•„ìš”

```

### **4.3 TURN ì„œë²„ (ì„ íƒì )**

### **ì—­í• **

```
âœ… ë°©í™”ë²½/ì—„ê²©í•œ NAT ìš°íšŒ
âœ… ë¹„ë””ì˜¤/ì˜¤ë””ì˜¤ ì¤‘ê³„
âœ… ì—°ê²° ì‹¤íŒ¨ ì‹œ ëŒ€ì•ˆ ê²½ë¡œ

```

### **í•„ìš”í•œ ê²½ìš°**

```jsx
// ì•½ 5~20%ì˜ ê²½ìš°:
- íšŒì‚¬/í•™êµ ë°©í™”ë²½
- ëŒ€ì¹­í˜• NAT
- VPN ì‚¬ìš©ì
- 4G/5G (í†µì‹ ì‚¬ë³„ ë‹¤ë¦„)

// ë‚˜ë¨¸ì§€ 80~95%ëŠ” STUNìœ¼ë¡œ ì¶©ë¶„!

```

### **ìœ ë£Œ ì„œë¹„ìŠ¤**

```
Twilio NAT Traversal: íŠ¸ë˜í”½ ê¸°ë°˜ ê³¼ê¸ˆ
Xirsys: $10/ì›”~
Metered.ca: $30/ì›”~

```

### **ì§ì ‘ êµ¬ì¶• (coturn)**

```bash
# Ubuntuì— coturn ì„¤ì¹˜
sudo apt-get install coturn

# ì„¤ì • íŒŒì¼ ìˆ˜ì •
sudo nano /etc/turnserver.conf

# ë‚´ìš©:
listening-port=3478
external-ip=YOUR_SERVER_IP
realm=yourdomain.com
user=username:password
lt-cred-mech

```

```jsx
// í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
const configuration = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    {
      urls: 'turn:your-turn-server.com:3478',
      username: 'username',
      credential: 'password'
    }
  ]
};

```

### **MVP ì¶”ì²œ**

```
ì´ˆê¸°: TURN ì—†ì´ ì‹œì‘
â†’ STUNë§Œìœ¼ë¡œ 80~95% ì—°ê²° ì„±ê³µ
â†’ ë¹„ìš© ì ˆê°

ì„±ì¥ê¸°: TURN ì¶”ê°€
â†’ ì—°ê²° ì„±ê³µë¥  99%+
â†’ coturn ì§ì ‘ êµ¬ì¶• or ìœ ë£Œ ì„œë¹„ìŠ¤

```

---

## **5. ë°”ë‹ë¼ JavaScriptë¡œ êµ¬í˜„í•˜ê¸°**

### **5.1 ê¸°ë³¸ êµ¬ì¡°**

### **ë””ë ‰í† ë¦¬ êµ¬ì¡°**

```
project/
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ style.css
â”‚   â””â”€â”€ main.js
â””â”€â”€ backend/
    â”œâ”€â”€ package.json
    â””â”€â”€ server.js

```

### **5.2 í”„ë¡ íŠ¸ì—”ë“œ (Vanilla JS)**

### **index.html**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>WebRTC í™”ìƒ í†µí™”</title>
  <style>
    video {
      width: 400px;
      height: 300px;
      background: #000;
      border: 2px solid #333;
    }
    #controls {
      margin: 20px 0;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
    }
</style>
</head>
<body>
  <h1>WebRTC í™”ìƒ í†µí™”</h1>

  <div id="controls">
    <input id="roomId" type="text" placeholder="ë°© ID ì…ë ¥">
    <button onclick="createRoom()">ë°© ë§Œë“¤ê¸°</button>
    <button onclick="joinRoom()">ë°© ì…ì¥</button>
    <button onclick="startCall()">í†µí™” ì‹œì‘</button>
    <button onclick="hangUp()">í†µí™” ì¢…ë£Œ</button>
  </div>

  <div id="videos">
    <div>
      <h3>ë‚´ í™”ë©´</h3>
      <video id="localVideo" autoplay muted></video>
    </div>
    <div>
      <h3>ìƒëŒ€ë°© í™”ë©´</h3>
      <video id="remoteVideo" autoplay></video>
    </div>
  </div>

  <div id="status"></div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script src="main.js"></script>
</body>
</html>

```

### **main.js (ì™„ì „í•œ êµ¬í˜„)**

```jsx
// ì‹œê·¸ë„ë§ ì„œë²„ ì—°ê²°
const socket = io('http://localhost:3000');

// WebRTC ì„¤ì •
const configuration = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' }
  ]
};

// ì „ì—­ ë³€ìˆ˜
let pc = null;
let localStream = null;
let roomId = null;
let remoteUserId = null;

// DOM ìš”ì†Œ
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const statusDiv = document.getElementById('status');

// ìƒíƒœ í‘œì‹œ
function updateStatus(message) {
  statusDiv.textContent = message;
  console.log(message);
}

// ë°© ìƒì„±
async function createRoom() {
  roomId = document.getElementById('roomId').value;
  if (!roomId) {
    alert('ë°© IDë¥¼ ì…ë ¥í•˜ì„¸ìš”');
    return;
  }

  socket.emit('create-room', roomId);
  updateStatus(`ë°© ìƒì„±ë¨: ${roomId}`);
}

// ë°© ì…ì¥
async function joinRoom() {
  roomId = document.getElementById('roomId').value;
  if (!roomId) {
    alert('ë°© IDë¥¼ ì…ë ¥í•˜ì„¸ìš”');
    return;
  }

  socket.emit('join-room', roomId);
  updateStatus(`ë°© ì…ì¥: ${roomId}`);
}

// ì›¹ìº  ì‹œì‘
async function startLocalStream() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    });

    localVideo.srcObject = localStream;
    updateStatus('ì›¹ìº  ì‹œì‘ë¨');

  } catch (error) {
    console.error('ì›¹ìº  ì ‘ê·¼ ì‹¤íŒ¨:', error);
    updateStatus('ì›¹ìº  ì ‘ê·¼ ì‹¤íŒ¨: ' + error.message);
  }
}

// PeerConnection ìƒì„±
function createPeerConnection(userId) {
  pc = new RTCPeerConnection(configuration);

  // ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ì¶”ê°€
  localStream.getTracks().forEach(track => {
    pc.addTrack(track, localStream);
  });

  // ICE Candidate ìˆ˜ì§‘
  pc.onicecandidate = (event) => {
    if (event.candidate) {
      console.log('ICE Candidate ë°œê²¬:', event.candidate.type);

      socket.emit('ice-candidate', {
        target: userId,
        candidate: event.candidate
      });
    }
  };

  // ìƒëŒ€ë°© ìŠ¤íŠ¸ë¦¼ ë°›ê¸°
  pc.ontrack = (event) => {
    console.log('ìƒëŒ€ë°© ìŠ¤íŠ¸ë¦¼ ë°›ìŒ');
    remoteVideo.srcObject = event.streams[0];
    updateStatus('ì—°ê²°ë¨');
  };

  // ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
  pc.onconnectionstatechange = () => {
    console.log('ì—°ê²° ìƒíƒœ:', pc.connectionState);
    updateStatus('ì—°ê²° ìƒíƒœ: ' + pc.connectionState);

    if (pc.connectionState === 'disconnected') {
      updateStatus('ì—°ê²° ëŠê¹€ - ì¬ì—°ê²° ì‹œë„ ì¤‘...');
      attemptReconnect();
    } else if (pc.connectionState === 'failed') {
      updateStatus('ì—°ê²° ì‹¤íŒ¨');
    }
  };

  // ICE ì—°ê²° ìƒíƒœ
  pc.oniceconnectionstatechange = () => {
    console.log('ICE ìƒíƒœ:', pc.iceConnectionState);
  };

  return pc;
}

// í†µí™” ì‹œì‘ (Offer ë³´ë‚´ëŠ” ìª½)
async function startCall() {
  if (!localStream) {
    await startLocalStream();
  }

  if (!remoteUserId) {
    updateStatus('ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...');
    return;
  }

  createPeerConnection(remoteUserId);

  try {
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    console.log('Offer ìƒì„±ë¨');
    socket.emit('offer', {
      target: remoteUserId,
      offer: offer
    });

    updateStatus('í†µí™” ì—°ê²° ì¤‘...');

  } catch (error) {
    console.error('Offer ìƒì„± ì‹¤íŒ¨:', error);
    updateStatus('í†µí™” ì‹œì‘ ì‹¤íŒ¨');
  }
}

// ì¬ì—°ê²° ì‹œë„
async function attemptReconnect() {
  setTimeout(async () => {
    if (pc.connectionState === 'disconnected') {
      console.log('ICE Restart ì‹œë„');

      const offer = await pc.createOffer({ iceRestart: true });
      await pc.setLocalDescription(offer);

      socket.emit('offer', {
        target: remoteUserId,
        offer: offer
      });
    }
  }, 5000);
}

// í†µí™” ì¢…ë£Œ
function hangUp() {
  if (pc) {
    pc.close();
    pc = null;
  }

  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
  }

  localVideo.srcObject = null;
  remoteVideo.srcObject = null;

  updateStatus('í†µí™” ì¢…ë£Œ');
}

// ì‹œê·¸ë„ë§ ì´ë²¤íŠ¸ ì²˜ë¦¬
socket.on('room-created', (room) => {
  console.log('ë°© ìƒì„±ë¨:', room);
  startLocalStream();
});

socket.on('user-joined', async (userId) => {
  console.log('ì‚¬ìš©ì ì…ì¥:', userId);
  remoteUserId = userId;
  updateStatus('ìƒëŒ€ë°©ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤');

  if (!localStream) {
    await startLocalStream();
  }

  // ìë™ìœ¼ë¡œ í†µí™” ì‹œì‘
  setTimeout(() => startCall(), 1000);
});

socket.on('offer', async (data) => {
  console.log('Offer ë°›ìŒ:', data.from);
  remoteUserId = data.from;

  if (!localStream) {
    await startLocalStream();
  }

  if (!pc) {
    createPeerConnection(remoteUserId);
  }

  try {
    await pc.setRemoteDescription(data.offer);

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    console.log('Answer ìƒì„±ë¨');
    socket.emit('answer', {
      target: remoteUserId,
      answer: answer
    });

    updateStatus('í†µí™” ì—°ê²° ì¤‘...');

  } catch (error) {
    console.error('Answer ìƒì„± ì‹¤íŒ¨:', error);
  }
});

socket.on('answer', async (data) => {
  console.log('Answer ë°›ìŒ:', data.from);

  try {
    await pc.setRemoteDescription(data.answer);
    console.log('Answer ì„¤ì • ì™„ë£Œ');

  } catch (error) {
    console.error('Answer ì„¤ì • ì‹¤íŒ¨:', error);
  }
});

socket.on('ice-candidate', async (data) => {
  console.log('ICE Candidate ë°›ìŒ');

  try {
    if (pc) {
      await pc.addIceCandidate(data.candidate);
      console.log('ICE Candidate ì¶”ê°€ë¨');
    }
  } catch (error) {
    console.error('ICE Candidate ì¶”ê°€ ì‹¤íŒ¨:', error);
  }
});

socket.on('user-left', (userId) => {
  console.log('ì‚¬ìš©ì í‡´ì¥:', userId);
  updateStatus('ìƒëŒ€ë°©ì´ ë‚˜ê°”ìŠµë‹ˆë‹¤');
  hangUp();
});

socket.on('error', (message) => {
  alert(message);
  updateStatus('ì—ëŸ¬: ' + message);
});

// í˜ì´ì§€ ì¢…ë£Œ ì‹œ ì •ë¦¬
window.addEventListener('beforeunload', () => {
  hangUp();
  socket.disconnect();
});

```

### **5.3 ë°±ì—”ë“œ (ì‹œê·¸ë„ë§ ì„œë²„)**

### **package.json**

```json
{
  "name": "webrtc-signaling-server",
  "version": "1.0.0",
  "description": "WebRTC Signaling Server",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.5.4"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}

```

### **server.js (ìœ„ 4.1 ì°¸ì¡°)**

### **5.4 ì‹¤í–‰ ë°©ë²•**

```bash
# ë°±ì—”ë“œ ì‹¤í–‰
cd backend
npm install
npm start

# í”„ë¡ íŠ¸ì—”ë“œ ì‹¤í–‰ (2ê°œ ë¸Œë¼ìš°ì €)
# 1ë²ˆ ë¸Œë¼ìš°ì €: ë°© ìƒì„±
# 2ë²ˆ ë¸Œë¼ìš°ì €: ë°© ì…ì¥

```

### **5.5 ë°”ë‹ë¼ JSì˜ ì¥ë‹¨ì **

### **ì¥ì **

```
âœ… ì˜ì¡´ì„± ì—†ìŒ (ìˆœìˆ˜ ì›¹ í‘œì¤€)
âœ… í•™ìŠµ ëª©ì ì— ìµœì 
âœ… ì™„ì „í•œ ì œì–´ ê°€ëŠ¥
âœ… ë²ˆë“¤ í¬ê¸° ìµœì†Œ
âœ… WebRTC ë™ì‘ ì›ë¦¬ ì™„ë²½ ì´í•´

```

### **ë‹¨ì **

```
âŒ ì½”ë“œëŸ‰ ë§ìŒ (ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸)
âŒ ì—ëŸ¬ ì²˜ë¦¬ ì§ì ‘ êµ¬í˜„
âŒ í¬ë¡œìŠ¤ ë¸Œë¼ìš°ì € ëŒ€ì‘ í•„ìš”
âŒ ë‹¤ì¤‘ ì—°ê²° ê´€ë¦¬ ë³µì¡
âŒ ê°œë°œ ì‹œê°„ ì˜¤ë˜ ê±¸ë¦¼

```

---

## **6. ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©í•˜ê¸°**

### **6.1 Simple-peer (ì¶”ì²œ!)**

### **íŠ¹ì§•**

```
âœ… WebRTC ë˜í¼ ë¼ì´ë¸ŒëŸ¬ë¦¬
âœ… ì½”ë“œëŸ‰ 90% ê°ì†Œ
âœ… ìë™ ì—ëŸ¬ ì²˜ë¦¬
âœ… í¬ë¡œìŠ¤ ë¸Œë¼ìš°ì € ì§€ì›
âœ… ë²ˆë“¤ í¬ê¸°: ~50KB

```

### **ì„¤ì¹˜**

```bash
npm install simple-peer

```

### **ì‚¬ìš© ì˜ˆì‹œ**

```jsx
import SimplePeer from 'simple-peer';
import io from 'socket.io-client';

const socket = io('http://localhost:3000');
let peer = null;

// ì›¹ìº  ì‹œì‘
navigator.mediaDevices.getUserMedia({
  video: true,
  audio: true
}).then(stream => {
  document.getElementById('localVideo').srcObject = stream;

  // SimplePeer ìƒì„± (Offer ë³´ë‚´ëŠ” ìª½)
  peer = new SimplePeer({
    initiator: true,  // ë¨¼ì € ì‹œì‘í•˜ëŠ” ìª½
    stream: stream,   // ë¡œì»¬ ìŠ¤íŠ¸ë¦¼
    trickle: false    // ICE Candidate í•œ ë²ˆì— ì „ì†¡
  });

  // Signal ë°ì´í„° ìƒì„± ì‹œ
  peer.on('signal', (data) => {
    console.log('Signal ìƒì„±ë¨ (Offer/ICE í¬í•¨)');

    // ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
    socket.emit('signal', data);
  });

  // ìƒëŒ€ë°© ìŠ¤íŠ¸ë¦¼ ë°›ì„ ì‹œ
  peer.on('stream', (remoteStream) => {
    console.log('ìƒëŒ€ë°© ìŠ¤íŠ¸ë¦¼ ë°›ìŒ');
    document.getElementById('remoteVideo').srcObject = remoteStream;
  });

  // ì—°ê²° ì™„ë£Œ
  peer.on('connect', () => {
    console.log('ì—°ê²° ì„±ê³µ!');
  });

  // ì—ëŸ¬ ì²˜ë¦¬
  peer.on('error', (err) => {
    console.error('ì—ëŸ¬:', err);
  });
});

// ìƒëŒ€ë°© Signal ë°›ê¸°
socket.on('signal', (data) => {
  if (peer) {
    peer.signal(data);  // Answer/ICE ì„¤ì •
  } else {
    // Answerë¥¼ ë³´ë‚´ëŠ” ìª½
    navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    }).then(stream => {
      document.getElementById('localVideo').srcObject = stream;

      peer = new SimplePeer({
        initiator: false,  // ì‘ë‹µí•˜ëŠ” ìª½
        stream: stream
      });

      peer.on('signal', (answerData) => {
        socket.emit('signal', answerData);
      });

      peer.on('stream', (remoteStream) => {
        document.getElementById('remoteVideo').srcObject = remoteStream;
      });

      peer.signal(data);  // Offer ì„¤ì •
    });
  }
});

```

### **ë°”ë‹ë¼ vs Simple-peer ë¹„êµ**

```jsx
// ë°”ë‹ë¼ JS (100ì¤„)
const pc = new RTCPeerConnection(config);
pc.onicecandidate = ...
pc.ontrack = ...
const offer = await pc.createOffer();
await pc.setLocalDescription(offer);
socket.emit('offer', offer);
// ... ë§ì€ ì½”ë“œ

// Simple-peer (10ì¤„)
const peer = new SimplePeer({ initiator: true, stream });
peer.on('signal', data => socket.emit('signal', data));
peer.on('stream', stream => video.srcObject = stream);
socket.on('signal', data => peer.signal(data));

```

### **6.2 PeerJS**

### **íŠ¹ì§•**

```
âœ… ë” ë†’ì€ ìˆ˜ì¤€ì˜ ì¶”ìƒí™”
âœ… ìì²´ ì‹œê·¸ë„ë§ ì„œë²„ ì œê³µ (ë¬´ë£Œ/ìœ ë£Œ)
âœ… ID ê¸°ë°˜ ì—°ê²° (ê°„í¸)

```

### **ì„¤ì¹˜**

```bash
npm install peerjs

```

### **ì‚¬ìš© ì˜ˆì‹œ**

```jsx
import Peer from 'peerjs';

// Peer ìƒì„± (ìë™ìœ¼ë¡œ ID ë¶€ì—¬)
const peer = new Peer({
  host: 'peerjs.com',  // ë¬´ë£Œ ì‹œê·¸ë„ë§ ì„œë²„
  port: 443,
  secure: true
});

peer.on('open', (id) => {
  console.log('ë‚´ ID:', id);
  // ì´ IDë¥¼ ìƒëŒ€ë°©ì—ê²Œ ì•Œë ¤ì£¼ë©´ ë¨
});

// ì›¹ìº  ì‹œì‘ í›„ ìƒëŒ€ë°©ì—ê²Œ ì „í™” ê±¸ê¸°
navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .then(stream => {
    document.getElementById('localVideo').srcObject = stream;

    // ìƒëŒ€ë°© IDë¡œ í†µí™” ì‹œì‘
    const call = peer.call('ìƒëŒ€ë°©-ID', stream);

    call.on('stream', (remoteStream) => {
      document.getElementById('remoteVideo').srcObject = remoteStream;
    });
  });

// ì „í™” ë°›ê¸°
peer.on('call', (call) => {
  navigator.mediaDevices.getUserMedia({ video: true, audio: true })
    .then(stream => {
      call.answer(stream);  // ì‘ë‹µ

      call.on('stream', (remoteStream) => {
        document.getElementById('remoteVideo').srcObject = remoteStream;
      });
    });
});

```

### **6.3 ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„ íƒ ê°€ì´ë“œ**

```jsx
Simple-peer:
âœ… ê°€ë³ê³  ë¹ ë¦„
âœ… ì»¤ìŠ¤í„°ë§ˆì´ì§• ì‰¬ì›€
âœ… ì‹œê·¸ë„ë§ ì„œë²„ ì§ì ‘ êµ¬ì¶•
â†’ ì¶”ì²œ: í•™ìŠµ + ì‹¤ì „

PeerJS:
âœ… ë§¤ìš° ê°„í¸
âœ… ì‹œê·¸ë„ë§ ì„œë²„ ì œê³µ
âœ… ID ê¸°ë°˜ ì—°ê²°
â†’ ì¶”ì²œ: í”„ë¡œí† íƒ€ì…, ê°„ë‹¨í•œ ì•±

ë°”ë‹ë¼ JS:
âœ… ì™„ì „í•œ ì œì–´
âœ… í•™ìŠµì— ìµœì 
âœ… ì˜ì¡´ì„± ì—†ìŒ
â†’ ì¶”ì²œ: í•™ìŠµ, íŠ¹ìˆ˜í•œ ìš”êµ¬ì‚¬í•­

```

---

## **7. ì‹¤ì „ ì˜ˆì œ: í‘œì • ì±Œë¦°ì§€ ê²Œì„**

### **7.1 í”„ë¡œì íŠ¸ ê°œìš”**

**ì»¨ì…‰:**Â í™”ìƒ ì±„íŒ… + í‘œì • ì¸ì‹ AIë¥¼ í™œìš©í•œ ì›ƒì°¸ ê²Œì„

**ê¸°ìˆ  ìŠ¤íƒ:**

```
í”„ë¡ íŠ¸ì—”ë“œ: React + face-api.js + Socket.io-client
ì‹œê·¸ë„ë§: Node.js + Socket.io
WebRTC: ë°”ë‹ë¼ or Simple-peer
í‘œì • ì¸ì‹: face-api.js (ë¸Œë¼ìš°ì € ë‚´ì¥ AI)

```

### **7.2 í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„**

### **7.2.1 í‘œì • ì¸ì‹ í†µí•©**

```jsx
// face-api.js ë¡œë“œ
import * as faceapi from 'face-api.js';

// ëª¨ë¸ ë¡œë“œ (í•œ ë²ˆë§Œ)
async function loadModels() {
  await faceapi.nets.tinyFaceDetector.loadFromUri('/models');
  await faceapi.nets.faceExpressionNet.loadFromUri('/models');
  console.log('ëª¨ë¸ ë¡œë“œ ì™„ë£Œ');
}

// ì‹¤ì‹œê°„ í‘œì • ì¸ì‹
async function detectExpression(videoElement) {
  const detections = await faceapi
    .detectSingleFace(videoElement, new faceapi.TinyFaceDetectorOptions())
    .withFaceExpressions();

  if (detections) {
    const expressions = detections.expressions;

    return {
      happy: expressions.happy,        // í–‰ë³µ (0~1)
      sad: expressions.sad,            // ìŠ¬í””
      angry: expressions.angry,        // ë¶„ë…¸
      surprised: expressions.surprised, // ë†€ëŒ
      neutral: expressions.neutral     // ë¬´í‘œì •
    };
  }

  return null;
}

// ê²Œì„ ë£¨í”„
function startGame() {
  const remoteVideo = document.getElementById('remoteVideo');

  setInterval(async () => {
    const emotions = await detectExpression(remoteVideo);

    if (emotions) {
      console.log('ìƒëŒ€ë°© í‘œì •:', emotions);

      // ì›ƒìŒ 70% ì´ìƒì´ë©´
      if (emotions.happy > 0.7) {
        console.log('ìƒëŒ€ë°©ì´ ì›ƒì—ˆë‹¤! ì ìˆ˜ íšë“!');
        addScore(10);
      }
    }
  }, 1000);  // 1ì´ˆë§ˆë‹¤ ì²´í¬
}

```

### **7.2.2 WebRTC + í‘œì • ì¸ì‹ í†µí•©**

```jsx
// React ì»´í¬ë„ŒíŠ¸ ì˜ˆì‹œ
import { useEffect, useRef, useState } from 'react';
import SimplePeer from 'simple-peer';
import io from 'socket.io-client';
import * as faceapi from 'face-api.js';

function EmotionChallengeGame() {
  const localVideoRef = useRef();
  const remoteVideoRef = useRef();
  const [myScore, setMyScore] = useState(0);
  const [opponentScore, setOpponentScore] = useState(0);
  const [currentEmotion, setCurrentEmotion] = useState(null);

  const socketRef = useRef();
  const peerRef = useRef();

  useEffect(() => {
    // 1. ëª¨ë¸ ë¡œë“œ
    loadFaceApiModels();

    // 2. ì‹œê·¸ë„ë§ ì„œë²„ ì—°ê²°
    socketRef.current = io('http://localhost:3000');

    // 3. ì›¹ìº  ì‹œì‘
    startWebcam();

    // 4. ì‹œê·¸ë„ë§ ì´ë²¤íŠ¸ ì„¤ì •
    setupSignaling();

    return () => {
      cleanup();
    };
  }, []);

  async function loadFaceApiModels() {
    await faceapi.nets.tinyFaceDetector.loadFromUri('/models');
    await faceapi.nets.faceExpressionNet.loadFromUri('/models');
  }

  async function startWebcam() {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    });

    localVideoRef.current.srcObject = stream;

    // SimplePeer ìƒì„±
    peerRef.current = new SimplePeer({
      initiator: true,
      stream: stream,
      trickle: false
    });

    peerRef.current.on('signal', (data) => {
      socketRef.current.emit('signal', data);
    });

    peerRef.current.on('stream', (remoteStream) => {
      remoteVideoRef.current.srcObject = remoteStream;

      // ìƒëŒ€ë°© ìŠ¤íŠ¸ë¦¼ ë°›ìœ¼ë©´ í‘œì • ì¸ì‹ ì‹œì‘
      startEmotionDetection();
    });
  }

  function setupSignaling() {
    socketRef.current.on('signal', (data) => {
      peerRef.current.signal(data);
    });

    socketRef.current.on('score-update', (data) => {
      setOpponentScore(data.score);
    });
  }

  function startEmotionDetection() {
    setInterval(async () => {
      const video = remoteVideoRef.current;

      if (video && video.readyState === 4) {
        const detections = await faceapi
          .detectSingleFace(video, new faceapi.TinyFaceDetectorOptions())
          .withFaceExpressions();

        if (detections) {
          const expressions = detections.expressions;
          setCurrentEmotion(expressions);

          // ê²Œì„ ëª¨ë“œì— ë”°ë¼ ì ìˆ˜ ê³„ì‚°
          if (gameMode === 'laugh' && expressions.happy > 0.7) {
            const newScore = myScore + 10;
            setMyScore(newScore);

            // ìƒëŒ€ë°©ì—ê²Œ ì ìˆ˜ ì „ì†¡
            socketRef.current.emit('score-update', { score: newScore });

            // POTG ìº¡ì²˜
            captureHighlight(expressions.happy);
          }
        }
      }
    }, 500);  // 0.5ì´ˆë§ˆë‹¤
  }

  function captureHighlight(emotionLevel) {
    // ìº”ë²„ìŠ¤ë¡œ í˜„ì¬ í”„ë ˆì„ ìº¡ì²˜
    const canvas = document.createElement('canvas');
    const video = remoteVideoRef.current;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);

    // ì´ë¯¸ì§€ë¡œ ì €ì¥
    const imageData = canvas.toDataURL('image/png');

    // POTG ì €ì¥
    savePOTG({
      timestamp: Date.now(),
      emotionLevel: emotionLevel,
      image: imageData
    });
  }

  return (
    <div className="game-container">
      <div className="scores">
        <div>ë‚´ ì ìˆ˜: {myScore}</div>
        <div>ìƒëŒ€ë°© ì ìˆ˜: {opponentScore}</div>
      </div>

      <div className="videos">
        <div>
          <h3>ë‚´ í™”ë©´</h3>
          <video ref={localVideoRef} autoPlay muted />
        </div>
        <div>
          <h3>ìƒëŒ€ë°© í™”ë©´</h3>
          <video ref={remoteVideoRef} autoPlay />

          {currentEmotion && (
            <div className="emotion-overlay">
              <div>ğŸ˜Š {(currentEmotion.happy * 100).toFixed(0)}%</div>
              <div>ğŸ˜¢ {(currentEmotion.sad * 100).toFixed(0)}%</div>
              <div>ğŸ˜® {(currentEmotion.surprised * 100).toFixed(0)}%</div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

```

### **7.3 ê²Œì„ ë¡œì§ ì„œë²„ (Node.js)**

```jsx
// server.js
const io = require('socket.io')(3000);

const games = new Map();  // roomId -> game state

io.on('connection', (socket) => {

  socket.on('join-game', (roomId) => {
    socket.join(roomId);

    if (!games.has(roomId)) {
      games.set(roomId, {
        players: [],
        scores: {},
        currentTurn: 0,
        mode: 'laugh',
        startTime: null
      });
    }

    const game = games.get(roomId);
    game.players.push(socket.id);
    game.scores[socket.id] = 0;

    // 2ëª… ëª¨ì´ë©´ ê²Œì„ ì‹œì‘
    if (game.players.length === 2) {
      game.startTime = Date.now();

      io.to(roomId).emit('game-start', {
        mode: game.mode,
        players: game.players
      });
    }
  });

  socket.on('score-update', (data) => {
    const roomId = getRoomId(socket);
    const game = games.get(roomId);

    if (game) {
      game.scores[socket.id] = data.score;

      // ëª¨ë“  í”Œë ˆì´ì–´ì—ê²Œ ì ìˆ˜ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      io.to(roomId).emit('scores-updated', game.scores);
    }
  });

  socket.on('potg-capture', (data) => {
    const roomId = getRoomId(socket);

    // POTG ì €ì¥ (DB or ë©”ëª¨ë¦¬)
    savePOTGToGame(roomId, {
      playerId: socket.id,
      ...data
    });
  });

  socket.on('disconnect', () => {
    // ê²Œì„ ì •ë¦¬
    const roomId = getRoomId(socket);
    if (roomId) {
      io.to(roomId).emit('player-left', socket.id);
      games.delete(roomId);
    }
  });
});

function getRoomId(socket) {
  return Array.from(socket.rooms).find(room => room !== socket.id);
}

```

### **7.4 í”„ë¡œì íŠ¸ êµ¬ì¡°**

```
emotion-challenge/
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â””â”€â”€ models/              # face-api.js ëª¨ë¸
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ Game.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ VideoCall.jsx
â”‚   â”‚   â”‚   â””â”€â”€ EmotionOverlay.jsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useWebRTC.js
â”‚   â”‚   â”‚   â””â”€â”€ useFaceDetection.js
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â””â”€â”€ emotionDetector.js
â”‚   â”‚   â””â”€â”€ App.jsx
â”‚   â””â”€â”€ package.json
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ server.js
â”‚   â”œâ”€â”€ gameManager.js
â”‚   â””â”€â”€ package.json
â””â”€â”€ README.md

```

---

## **8. íŠ¸ëŸ¬ë¸”ìŠˆíŒ…**

### **8.1 ìì£¼ ë°œìƒí•˜ëŠ” ë¬¸ì œ**

### **ë¬¸ì œ 1: ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œ ê±°ë¶€**

```jsx
// ì—ëŸ¬ ì²˜ë¦¬
navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .catch(error => {
    if (error.name === 'NotAllowedError') {
      alert('ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”');
    } else if (error.name === 'NotFoundError') {
      alert('ì¹´ë©”ë¼/ë§ˆì´í¬ê°€ ì—°ê²°ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤');
    } else if (error.name === 'NotReadableError') {
      alert('ì¹´ë©”ë¼/ë§ˆì´í¬ê°€ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤');
    } else {
      alert('ë¯¸ë””ì–´ ì ‘ê·¼ ì‹¤íŒ¨: ' + error.message);
    }
  });

```

### **ë¬¸ì œ 2: ICE ì—°ê²° ì‹¤íŒ¨**

```jsx
// ë””ë²„ê¹…
pc.onicecandidateerror = (event) => {
  console.error('ICE ì—ëŸ¬:', event.errorCode, event.errorText);
};

pc.oniceconnectionstatechange = () => {
  if (pc.iceConnectionState === 'failed') {
    console.log('ICE ì‹¤íŒ¨ - TURN ì„œë²„ ì¶”ê°€ í•„ìš”');

    // TURN ì„œë²„ë¡œ ì¬ì‹œë„
    recreatePeerConnectionWithTURN();
  }
};

```

### **ë¬¸ì œ 3: Offer/Answer íƒ€ì´ë° ë¬¸ì œ**

```jsx
// ì˜ëª»ëœ ì½”ë“œ (Race Condition)
socket.on('offer', async (offer) => {
  await pc.setRemoteDescription(offer);  // ì—ëŸ¬ ê°€ëŠ¥!
});

// ì˜¬ë°”ë¥¸ ì½”ë“œ
socket.on('offer', async (offer) => {
  // ìƒíƒœ ì²´í¬
  if (pc.signalingState !== 'stable') {
    console.warn('ì•„ì§ ì¤€ë¹„ ì•ˆë¨, ëŒ€ê¸° ì¤‘...');
    return;
  }

  await pc.setRemoteDescription(offer);
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  socket.emit('answer', answer);
});

```

### **ë¬¸ì œ 4: ì—¬ëŸ¬ ëª… ì—°ê²° ê´€ë¦¬**

```jsx
// ê° ì°¸ì—¬ìë³„ PeerConnection ê´€ë¦¬
const peerConnections = new Map();

function createPeerConnectionForUser(userId) {
  const pc = new RTCPeerConnection(config);

  // ì„¤ì •...

  peerConnections.set(userId, pc);
  return pc;
}

function removePeerConnection(userId) {
  const pc = peerConnections.get(userId);
  if (pc) {
    pc.close();
    peerConnections.delete(userId);
  }
}

// ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
window.addEventListener('beforeunload', () => {
  peerConnections.forEach(pc => pc.close());
  peerConnections.clear();
});

```

### **8.2 ë””ë²„ê¹… ë„êµ¬**

### **Chrome WebRTC Internals**

```
chrome://webrtc-internals/

í™•ì¸ ê°€ëŠ¥ ì •ë³´:
- ICE candidates
- ì—°ê²° ìƒíƒœ
- í†µê³„ ê·¸ë˜í”„
- íŒ¨í‚· ì†ì‹¤ë¥ 
- ë¹„íŠ¸ë ˆì´íŠ¸

```

### **ì½”ë“œë¡œ í†µê³„ í™•ì¸**

```jsx
setInterval(async () => {
  const stats = await pc.getStats();

  stats.forEach(report => {
    if (report.type === 'inbound-rtp' && report.kind === 'video') {
      console.log('ë°›ì€ íŒ¨í‚·:', report.packetsReceived);
      console.log('íŒ¨í‚· ì†ì‹¤:', report.packetsLost);
      console.log('ì§€í„°:', report.jitter);
    }

    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
      console.log('RTT (ì™•ë³µì‹œê°„):', report.currentRoundTripTime);
    }
  });
}, 5000);

```

### **8.3 ì„±ëŠ¥ ìµœì í™”**

### **ë¹„ë””ì˜¤ í’ˆì§ˆ ì¡°ì ˆ**

```jsx
// ë‚®ì€ í•´ìƒë„ë¡œ ì‹œì‘ (ëŒ€ì—­í­ ì ˆì•½)
const stream = await navigator.mediaDevices.getUserMedia({
  video: {
    width: { ideal: 640 },
    height: { ideal: 480 },
    frameRate: { ideal: 15, max: 30 }
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true
  }
});

// ëŸ°íƒ€ì„ì— ë¹„íŠ¸ë ˆì´íŠ¸ ì¡°ì •
const sender = pc.getSenders().find(s => s.track.kind === 'video');
const parameters = sender.getParameters();

if (!parameters.encodings) {
  parameters.encodings = [{}];
}

parameters.encodings[0].maxBitrate = 500000;  // 500kbps
await sender.setParameters(parameters);

```

---

## **9. ì²´í¬ë¦¬ìŠ¤íŠ¸**

### **9.1 ê°œë°œ ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸**

```
â–¡ WebRTC ê¸°ë³¸ ê°œë… ì´í•´
  â–¡ P2P ì—°ê²° ë°©ì‹
  â–¡ ì‹œê·¸ë„ë§ í”„ë¡œì„¸ìŠ¤
  â–¡ ICE ì‘ë™ ì›ë¦¬

â–¡ í•„ìš”í•œ ì„œë²„ ì¤€ë¹„
  â–¡ ì‹œê·¸ë„ë§ ì„œë²„ (í•„ìˆ˜)
  â–¡ STUN ì„œë²„ (ë¬´ë£Œ ì‚¬ìš©)
  â–¡ TURN ì„œë²„ (ì„ íƒ, ë‚˜ì¤‘ì— ì¶”ê°€)

â–¡ ê¸°ìˆ  ìŠ¤íƒ ì„ íƒ
  â–¡ ë°”ë‹ë¼ JS or ë¼ì´ë¸ŒëŸ¬ë¦¬
  â–¡ í”„ë¡ íŠ¸ì—”ë“œ í”„ë ˆì„ì›Œí¬
  â–¡ ë°±ì—”ë“œ ì–¸ì–´/í”„ë ˆì„ì›Œí¬

â–¡ ê°œë°œ í™˜ê²½ ì„¤ì •
  â–¡ HTTPS (localhostëŠ” HTTP ê°€ëŠ¥)
  â–¡ ë¸Œë¼ìš°ì € ê¶Œí•œ (ì¹´ë©”ë¼/ë§ˆì´í¬)

```

### **9.2 êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸**

```
â–¡ ì‹œê·¸ë„ë§ ì„œë²„ êµ¬í˜„
  â–¡ WebSocket/Socket.io ì„œë²„
  â–¡ ë°© ê´€ë¦¬ ë¡œì§
  â–¡ Offer/Answer ì¤‘ê³„
  â–¡ ICE Candidate ì¤‘ê³„

â–¡ WebRTC í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
  â–¡ RTCPeerConnection ìƒì„±
  â–¡ getUserMediaë¡œ ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¼
  â–¡ ICE Candidate ìˆ˜ì§‘
  â–¡ Offer/Answer ìƒì„±
  â–¡ ì›ê²© ìŠ¤íŠ¸ë¦¼ í‘œì‹œ

â–¡ ì—ëŸ¬ ì²˜ë¦¬
  â–¡ ê¶Œí•œ ê±°ë¶€ ì²˜ë¦¬
  â–¡ ì—°ê²° ì‹¤íŒ¨ ì²˜ë¦¬
  â–¡ ì¬ì—°ê²° ë¡œì§
  â–¡ íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬

â–¡ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
  â–¡ PeerConnection.close()
  â–¡ MediaStreamTrack.stop()
  â–¡ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
  â–¡ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€

```

### **9.3 ë°°í¬ ì²´í¬ë¦¬ìŠ¤íŠ¸**

```
â–¡ HTTPS í•„ìˆ˜
  â–¡ Let's Encrypt ì¸ì¦ì„œ
  â–¡ ë˜ëŠ” í´ë¼ìš°ë“œ ì œê³µ SSL

â–¡ STUN/TURN ì„œë²„ ì„¤ì •
  â–¡ ê³µê°œ STUN ì„œë²„ (ë¬´ë£Œ)
  â–¡ TURN ì„œë²„ (í•„ìš”ì‹œ)

â–¡ ë°©í™”ë²½ ì„¤ì •
  â–¡ WebSocket í¬íŠ¸ ì˜¤í”ˆ
  â–¡ UDP í¬íŠ¸ ì˜¤í”ˆ (WebRTC)

â–¡ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  â–¡ ì—°ê²° ì„±ê³µë¥ 
  â–¡ íŒ¨í‚· ì†ì‹¤ë¥ 
  â–¡ ì§€ì—° ì‹œê°„

â–¡ ë¸Œë¼ìš°ì € í˜¸í™˜ì„±
  â–¡ Chrome/Edge í…ŒìŠ¤íŠ¸
  â–¡ Firefox í…ŒìŠ¤íŠ¸
  â–¡ Safari í…ŒìŠ¤íŠ¸
  â–¡ ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € í…ŒìŠ¤íŠ¸

```

---

## **10. í•™ìŠµ ë¡œë“œë§µ**

### **10.1 ì´ˆê¸‰ (1ì£¼)**

```
Day 1-2: ê°œë… ì´í•´
- WebRTCê°€ ë­”ì§€
- P2P vs ì„œë²„ ì¤‘ê³„
- í•„ìš”í•œ ì„œë²„ë“¤

Day 3-4: ê°„ë‹¨í•œ ì˜ˆì œ
- ë°”ë‹ë¼ JSë¡œ 1:1 í™”ìƒ í†µí™”
- ì‹œê·¸ë„ë§ ì„œë²„ êµ¬ì¶•

Day 5-7: ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
- Simple-peer ì‚¬ìš©
- ì½”ë“œ ë¦¬íŒ©í† ë§

```

### **10.2 ì¤‘ê¸‰ (2ì£¼)**

```
Week 1: ê³ ê¸‰ ê¸°ëŠ¥
- DataChannel ì‚¬ìš©
- í™”ë©´ ê³µìœ 
- ë‹¤ì¤‘ ì—°ê²° (3ëª… ì´ìƒ)

Week 2: ì—ëŸ¬ ì²˜ë¦¬
- ì¬ì—°ê²° ë¡œì§
- TURN ì„œë²„ ì¶”ê°€
- ì„±ëŠ¥ ìµœì í™”

```

### **10.3 ê³ ê¸‰ (1ê°œì›”)**

```
Week 1-2: ì‹¤ì „ í”„ë¡œì íŠ¸
- í™”ìƒ íšŒì˜ ì•±
- ê²Œì„ í†µí•© (í‘œì • ì±Œë¦°ì§€ ë“±)

Week 3-4: ë°°í¬ ë° ìš´ì˜
- í”„ë¡œë•ì…˜ ë°°í¬
- ëª¨ë‹ˆí„°ë§
- ìŠ¤ì¼€ì¼ë§

```

---

## **11. ì°¸ê³  ìë£Œ**

### **11.1 ê³µì‹ ë¬¸ì„œ**

```
WebRTC ê³µì‹:
https://webrtc.org/

MDN WebRTC API:
https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API

W3C í‘œì¤€:
https://www.w3.org/TR/webrtc/

```

### **11.2 ë¼ì´ë¸ŒëŸ¬ë¦¬**

```
Simple-peer:
https://github.com/feross/simple-peer

PeerJS:
https://peerjs.com/

Socket.io:
https://socket.io/

```

### **11.3 ë¬´ë£Œ STUN/TURN**

```
Google STUN:
stun:stun.l.google.com:19302

Mozilla STUN:
stun:stun.services.mozilla.com

ë¬´ë£Œ TURN (ì œí•œì ):
https://www.metered.ca/tools/openrelay/

```

---

## **ë§ˆì¹˜ë©°**

WebRTCëŠ” ì²˜ìŒì—” ë³µì¡í•´ ë³´ì´ì§€ë§Œ, í•µì‹¬ ê°œë…ì„ ì´í•´í•˜ë©´ ê°•ë ¥í•œ ì‹¤ì‹œê°„ í†µì‹  ì•±ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**í•µì‹¬ í¬ì¸íŠ¸:**

1. P2P ì§ì ‘ ì—°ê²° (ì„œë²„ ë¶€í•˜ ë‚®ìŒ)
2. ì‹œê·¸ë„ë§ì€ ì´ˆê¸°ì—ë§Œ í•„ìš”
3. ICEê°€ ìë™ìœ¼ë¡œ ìµœì  ê²½ë¡œ ì°¾ìŒ
4. í‘œì¤€ API (ë¸Œë¼ìš°ì € ë‚´ì¥)
5. ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ê°„í¸í•˜ê²Œ ì‹œì‘ ê°€ëŠ¥

**í•™ìŠµ ìˆœì„œ:**

1. ë°”ë‹ë¼ JSë¡œ ê°œë… ì´í•´
2. Simple-peerë¡œ ë¹ ë¥¸ ê°œë°œ
3. ì‹¤ì „ í”„ë¡œì íŠ¸ë¡œ ê²½í—˜ ì¶•ì 

í™”ì´íŒ…! ğŸš€