# WebRTC í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„ ê°€ì´ë“œ

> Socket.IO + WebRTCë¡œ í™”ìƒ ì±„íŒ… êµ¬í˜„í•˜ê¸°

## ëª©ì°¨
1. [ì „ì²´ ì•„í‚¤í…ì²˜](#ì „ì²´-ì•„í‚¤í…ì²˜)
2. [êµ¬í˜„ ìˆœì„œ](#êµ¬í˜„-ìˆœì„œ)
3. [ë‹¨ê³„ë³„ ìƒì„¸ ì½”ë“œ](#ë‹¨ê³„ë³„-ìƒì„¸-ì½”ë“œ)
4. [í›… êµ¬ì¡° ì„¤ê³„](#í›…-êµ¬ì¡°-ì„¤ê³„)
5. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](#íŠ¸ëŸ¬ë¸”ìŠˆíŒ…)

---

## ì „ì²´ ì•„í‚¤í…ì²˜

### í•µì‹¬ ê°œë…

```
[í´ë¼ì´ì–¸íŠ¸ A]                    [ì„œë²„]                    [í´ë¼ì´ì–¸íŠ¸ B]
     â”‚                             â”‚                             â”‚
     â”‚  Socket.IO (ì‹œê·¸ë„ë§)       â”‚                             â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€ Offer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â–º Offer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€ Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â—„â”€â”€â”€â”€â”€â”€ Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚â—„â”€â”€â”€â”€ ICE Candidate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â–º ICE Candidate â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
     â”‚                             â”‚                             â”‚
     â”‚         (ì‹œê·¸ë„ë§ ì™„ë£Œ)      â”‚                             â”‚
     â”‚                             â”‚                             â”‚
     â”‚  WebRTC (P2P ë¯¸ë””ì–´)                                      â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
     â”‚          ë¹„ë””ì˜¤/ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ (ì„œë²„ ê²½ìœ  X)                â”‚
     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
```

### ì¤‘ìš” í¬ì¸íŠ¸

1. **ì„œë²„ ì—­í• **: Offer/Answer/ICEë§Œ ì¤‘ê³„ (ì‹œê·¸ë„ë§)
2. **ë¯¸ë””ì–´ ì „ì†¡**: í´ë¼ì´ì–¸íŠ¸ ê°„ ì§ì ‘ P2P
3. **ì„œë²„ëŠ” ë¯¸ë””ì–´ë¥¼ ë°›ì§€ë„, ë³´ë‚´ì§€ë„ ì•ŠìŒ!**

---

## êµ¬í˜„ ìˆœì„œ

### âœ… ì¶”ì²œ: ì ì§„ì  ê°œë°œ

```
Phase 1: Socket.IO ì—°ê²° í…ŒìŠ¤íŠ¸ (30ë¶„)
  â†“
Phase 2: ë°© ì‹œìŠ¤í…œ (2ì‹œê°„)
  â†“
Phase 3: 1:1 WebRTC ì—°ê²° (4ì‹œê°„)
  â†“
Phase 4: ë‹¤ì¤‘ ì‚¬ìš©ì (4ì‹œê°„)
  â†“
Phase 5: UI ê°œì„  (2ì‹œê°„)
```

**ì´ ì†Œìš” ì‹œê°„**: 12-15ì‹œê°„

### âŒ ë¹„ì¶”ì²œ: í•œ ë²ˆì— ë‹¤ ë§Œë“¤ê¸°

```
ë¡œì§ ì „ë¶€ ì‘ì„±
  â†“
UI ì—°ê²°
  â†“
âŒ ë””ë²„ê¹… ì§€ì˜¥ (ì–´ë””ì„œ ë¬¸ì œì¸ì§€ ëª¨ë¦„)
```

---

## Phase 1: Socket.IO ì—°ê²° í…ŒìŠ¤íŠ¸

### ëª©í‘œ
- Socket.IO í´ë¼ì´ì–¸íŠ¸ ì„¤ì¹˜ ë° ì—°ê²°
- ì„œë²„ í†µì‹  í™•ì¸

### 1-1. íŒ¨í‚¤ì§€ ì„¤ì¹˜

```bash
cd frontend
npm install socket.io-client
```

### 1-2. Socket ì—°ê²° í›… ìƒì„±

```typescript
// src/hooks/useSocket.ts
import { useEffect, useState } from 'react'
import { io, Socket } from 'socket.io-client'

const SERVER_URL = 'http://localhost:3000'

export function useSocket() {
  const [socket, setSocket] = useState<Socket | null>(null)
  const [isConnected, setIsConnected] = useState(false)

  useEffect(() => {
    // ì†Œì¼“ ìƒì„±
    const newSocket = io(SERVER_URL)

    // ì—°ê²° ì„±ê³µ
    newSocket.on('connect', () => {
      console.log('âœ… Socket ì—°ê²°:', newSocket.id)
      setIsConnected(true)
    })

    // ì—°ê²° í•´ì œ
    newSocket.on('disconnect', () => {
      console.log('âŒ Socket ì—°ê²° í•´ì œ')
      setIsConnected(false)
    })

    setSocket(newSocket)

    // í´ë¦°ì—…
    return () => {
      newSocket.close()
    }
  }, [])

  return { socket, isConnected }
}
```

### 1-3. í…ŒìŠ¤íŠ¸ ì»´í¬ë„ŒíŠ¸

```typescript
// src/pages/TestPage.tsx
import { useSocket } from '@/hooks/useSocket'

export default function TestPage() {
  const { socket, isConnected } = useSocket()

  return (
    <div>
      <h1>Socket.IO ì—°ê²° í…ŒìŠ¤íŠ¸</h1>
      <p>ìƒíƒœ: {isConnected ? 'âœ… ì—°ê²°ë¨' : 'âŒ ì—°ê²° ì•ˆ ë¨'}</p>
      {socket && <p>ID: {socket.id}</p>}
    </div>
  )
}
```

### 1-4. í™•ì¸ ì‚¬í•­

- [ ] ë¸Œë¼ìš°ì € ì½˜ì†”ì— "âœ… Socket ì—°ê²°" í‘œì‹œ
- [ ] ì„œë²„ ì½˜ì†”ì— "ìƒˆ ì—°ê²°" ë¡œê·¸
- [ ] í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ ì‹œ ì¬ì—°ê²°

---

## Phase 2: ë°© ì‹œìŠ¤í…œ

### ëª©í‘œ
- ë°© ëª©ë¡ ì¡°íšŒ
- ë°© ìƒì„±/ì…ì¥
- ê¸°ì¡´ ì°¸ì—¬ì í™•ì¸

### 2-1. ë°© ê´€ë¦¬ í›…

```typescript
// src/hooks/useRoom.ts
import { useState, useEffect } from 'react'
import { Socket } from 'socket.io-client'

interface Room {
  id: string
  userCount: number
  createdAt: string
}

export function useRoom(socket: Socket | null) {
  const [rooms, setRooms] = useState<Room[]>([])
  const [currentRoom, setCurrentRoom] = useState<string | null>(null)
  const [users, setUsers] = useState<string[]>([])

  // ë°© ëª©ë¡ ì¡°íšŒ
  const fetchRooms = async () => {
    try {
      const response = await fetch('http://localhost:3000/rooms')
      const data = await response.json()
      setRooms(data.rooms)
    } catch (error) {
      console.error('ë°© ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:', error)
    }
  }

  // ë°© ìƒì„±
  const createRoom = (roomId: string) => {
    if (!socket) return

    socket.emit('create-room', roomId, (response: any) => {
      if (response.success) {
        console.log('âœ… ë°© ìƒì„±:', roomId)
        setCurrentRoom(roomId)
        setUsers([socket.id!])
      } else {
        console.error('âŒ ë°© ìƒì„± ì‹¤íŒ¨:', response.error)
        alert(response.error)
      }
    })
  }

  // ë°© ì…ì¥
  const joinRoom = (roomId: string) => {
    if (!socket) return

    socket.emit('join-room', roomId, (response: any) => {
      if (response.success) {
        console.log('âœ… ë°© ì…ì¥:', roomId)
        console.log('ê¸°ì¡´ ì°¸ì—¬ì:', response.existingUsers)
        setCurrentRoom(roomId)
        setUsers([socket.id!, ...response.existingUsers])
      } else {
        console.error('âŒ ë°© ì…ì¥ ì‹¤íŒ¨:', response.error)
        alert(response.error)
      }
    })
  }

  // ë°© ë‚˜ê°€ê¸°
  const leaveRoom = () => {
    if (!socket || !currentRoom) return

    socket.emit('leave-room')
    setCurrentRoom(null)
    setUsers([])
  }

  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
  useEffect(() => {
    if (!socket) return

    // ìƒˆ ì‚¬ìš©ì ì…ì¥
    socket.on('user-joined', ({ userId }) => {
      console.log('ğŸ‘¤ ì‚¬ìš©ì ì…ì¥:', userId)
      setUsers(prev => [...prev, userId])
    })

    // ì‚¬ìš©ì í‡´ì¥
    socket.on('user-left', ({ userId }) => {
      console.log('ğŸ‘‹ ì‚¬ìš©ì í‡´ì¥:', userId)
      setUsers(prev => prev.filter(id => id !== userId))
    })

    return () => {
      socket.off('user-joined')
      socket.off('user-left')
    }
  }, [socket])

  return {
    rooms,
    currentRoom,
    users,
    fetchRooms,
    createRoom,
    joinRoom,
    leaveRoom
  }
}
```

### 2-2. ë°© ëª©ë¡ UI

```typescript
// src/components/RoomList.tsx
import { useEffect } from 'react'

interface RoomListProps {
  rooms: Room[]
  onFetchRooms: () => void
  onJoinRoom: (roomId: string) => void
}

export function RoomList({ rooms, onFetchRooms, onJoinRoom }: RoomListProps) {
  useEffect(() => {
    onFetchRooms()
    const interval = setInterval(onFetchRooms, 5000) // 5ì´ˆë§ˆë‹¤ ê°±ì‹ 
    return () => clearInterval(interval)
  }, [])

  return (
    <div>
      <h2>í™œì„± ë°© ëª©ë¡</h2>
      {rooms.length === 0 ? (
        <p>ìƒì„±ëœ ë°©ì´ ì—†ìŠµë‹ˆë‹¤</p>
      ) : (
        <ul>
          {rooms.map(room => (
            <li key={room.id}>
              <span>{room.id}</span>
              <span>{room.userCount}ëª…</span>
              <button onClick={() => onJoinRoom(room.id)}>
                ì…ì¥
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  )
}
```

### 2-3. ë°© ìƒì„± UI

```typescript
// src/components/CreateRoom.tsx
import { useState } from 'react'

interface CreateRoomProps {
  onCreateRoom: (roomId: string) => void
}

export function CreateRoom({ onCreateRoom }: CreateRoomProps) {
  const [roomId, setRoomId] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (roomId.trim()) {
      onCreateRoom(roomId.trim())
      setRoomId('')
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <h2>ë°© ìƒì„±</h2>
      <input
        type="text"
        value={roomId}
        onChange={(e) => setRoomId(e.target.value)}
        placeholder="ë°© ID ì…ë ¥"
      />
      <button type="submit">ìƒì„±</button>
    </form>
  )
}
```

### 2-4. í†µí•© í˜ì´ì§€

```typescript
// src/pages/RoomPage.tsx
import { useSocket } from '@/hooks/useSocket'
import { useRoom } from '@/hooks/useRoom'
import { RoomList } from '@/components/RoomList'
import { CreateRoom } from '@/components/CreateRoom'

export default function RoomPage() {
  const { socket, isConnected } = useSocket()
  const {
    rooms,
    currentRoom,
    users,
    fetchRooms,
    createRoom,
    joinRoom,
    leaveRoom
  } = useRoom(socket)

  if (!isConnected) {
    return <div>ì„œë²„ ì—°ê²° ì¤‘...</div>
  }

  if (currentRoom) {
    return (
      <div>
        <h1>ë°©: {currentRoom}</h1>
        <p>ì°¸ì—¬ì ({users.length}ëª…):</p>
        <ul>
          {users.map(userId => (
            <li key={userId}>{userId}</li>
          ))}
        </ul>
        <button onClick={leaveRoom}>ë°© ë‚˜ê°€ê¸°</button>
      </div>
    )
  }

  return (
    <div>
      <h1>WebRTC í™”ìƒ ì±„íŒ…</h1>
      <CreateRoom onCreateRoom={createRoom} />
      <RoomList
        rooms={rooms}
        onFetchRooms={fetchRooms}
        onJoinRoom={joinRoom}
      />
    </div>
  )
}
```

---

## Phase 3: WebRTC ì—°ê²° (í•µì‹¬!)

### ëª©í‘œ
- RTCPeerConnection ìƒì„±
- Offer/Answer êµí™˜
- ICE Candidate êµí™˜
- ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¼ ì†¡ìˆ˜ì‹ 

### 3-1. WebRTC í›…

```typescript
// src/hooks/useWebRTC.ts
import { useEffect, useRef, useState } from 'react'
import { Socket } from 'socket.io-client'

const STUN_SERVERS = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' }
  ]
}

export function useWebRTC(socket: Socket | null, roomUsers: string[]) {
  const [localStream, setLocalStream] = useState<MediaStream | null>(null)
  const [remoteStreams, setRemoteStreams] = useState<Map<string, MediaStream>>(new Map())

  // userId â†’ RTCPeerConnection
  const peerConnections = useRef<Map<string, RTCPeerConnection>>(new Map())

  const localVideoRef = useRef<HTMLVideoElement>(null)

  // ========================================
  // 1. ë¡œì»¬ ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¼ íšë“
  // ========================================
  const startLocalStream = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      })

      setLocalStream(stream)

      // ë¡œì»¬ ë¹„ë””ì˜¤ì— í‘œì‹œ
      if (localVideoRef.current) {
        localVideoRef.current.srcObject = stream
      }

      console.log('âœ… ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ íšë“')
    } catch (error) {
      console.error('âŒ ë¯¸ë””ì–´ ì ‘ê·¼ ì‹¤íŒ¨:', error)
      alert('ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤')
    }
  }

  // ========================================
  // 2. PeerConnection ìƒì„±
  // ========================================
  const createPeerConnection = (userId: string): RTCPeerConnection => {
    const pc = new RTCPeerConnection(STUN_SERVERS)

    // ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ì¶”ê°€
    if (localStream) {
      localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream)
      })
    }

    // ICE Candidate ì´ë²¤íŠ¸
    pc.onicecandidate = (event) => {
      if (event.candidate && socket) {
        console.log('ğŸ“¤ ICE Candidate ì „ì†¡ â†’', userId)
        socket.emit('ice-candidate', {
          target: userId,
          candidate: event.candidate
        })
      }
    }

    // ì›ê²© ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹ 
    pc.ontrack = (event) => {
      console.log('ğŸ“¥ ì›ê²© ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹  â†', userId)
      setRemoteStreams(prev => {
        const newMap = new Map(prev)
        newMap.set(userId, event.streams[0])
        return newMap
      })
    }

    // ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
    pc.onconnectionstatechange = () => {
      console.log(`ğŸ”— ${userId} ì—°ê²° ìƒíƒœ:`, pc.connectionState)
    }

    peerConnections.current.set(userId, pc)
    return pc
  }

  // ========================================
  // 3. Offer ìƒì„± ë° ì „ì†¡
  // ========================================
  const createOffer = async (userId: string) => {
    if (!socket) return

    const pc = createPeerConnection(userId)

    try {
      const offer = await pc.createOffer()
      await pc.setLocalDescription(offer)

      console.log('ğŸ“¤ Offer ì „ì†¡ â†’', userId)
      socket.emit('offer', {
        target: userId,
        offer: offer
      })
    } catch (error) {
      console.error('âŒ Offer ìƒì„± ì‹¤íŒ¨:', error)
    }
  }

  // ========================================
  // 4. Socket ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
  // ========================================
  useEffect(() => {
    if (!socket || !localStream) return

    // Offer ìˆ˜ì‹ 
    socket.on('offer', async ({ offer, from }) => {
      console.log('ğŸ“¥ Offer ìˆ˜ì‹  â†', from)

      const pc = createPeerConnection(from)

      try {
        await pc.setRemoteDescription(offer)
        const answer = await pc.createAnswer()
        await pc.setLocalDescription(answer)

        console.log('ğŸ“¤ Answer ì „ì†¡ â†’', from)
        socket.emit('answer', {
          target: from,
          answer: answer
        })
      } catch (error) {
        console.error('âŒ Answer ìƒì„± ì‹¤íŒ¨:', error)
      }
    })

    // Answer ìˆ˜ì‹ 
    socket.on('answer', async ({ answer, from }) => {
      console.log('ğŸ“¥ Answer ìˆ˜ì‹  â†', from)

      const pc = peerConnections.current.get(from)
      if (pc) {
        try {
          await pc.setRemoteDescription(answer)
        } catch (error) {
          console.error('âŒ Answer ì„¤ì • ì‹¤íŒ¨:', error)
        }
      }
    })

    // ICE Candidate ìˆ˜ì‹ 
    socket.on('ice-candidate', async ({ candidate, from }) => {
      console.log('ğŸ“¥ ICE Candidate ìˆ˜ì‹  â†', from)

      const pc = peerConnections.current.get(from)
      if (pc) {
        try {
          await pc.addIceCandidate(candidate)
        } catch (error) {
          console.error('âŒ ICE Candidate ì¶”ê°€ ì‹¤íŒ¨:', error)
        }
      }
    })

    // ìƒˆ ì‚¬ìš©ì ì…ì¥ â†’ Offer ìƒì„±
    socket.on('user-joined', ({ userId }) => {
      console.log('ğŸ‘¤ ìƒˆ ì‚¬ìš©ì ì…ì¥:', userId)
      // ì ê¹ ëŒ€ê¸° í›„ Offer ì „ì†¡ (ì–‘ìª½ ë™ì‹œ Offer ë°©ì§€)
      setTimeout(() => createOffer(userId), 1000)
    })

    // ì‚¬ìš©ì í‡´ì¥ â†’ PeerConnection ì •ë¦¬
    socket.on('user-left', ({ userId }) => {
      console.log('ğŸ‘‹ ì‚¬ìš©ì í‡´ì¥:', userId)
      const pc = peerConnections.current.get(userId)
      if (pc) {
        pc.close()
        peerConnections.current.delete(userId)
      }
      setRemoteStreams(prev => {
        const newMap = new Map(prev)
        newMap.delete(userId)
        return newMap
      })
    })

    return () => {
      socket.off('offer')
      socket.off('answer')
      socket.off('ice-candidate')
      socket.off('user-joined')
      socket.off('user-left')
    }
  }, [socket, localStream])

  // ========================================
  // 5. ê¸°ì¡´ ì°¸ì—¬ìë“¤ì—ê²Œ ì—°ê²°
  // ========================================
  useEffect(() => {
    if (!socket || !localStream || roomUsers.length === 0) return

    // ë³¸ì¸ ì œì™¸í•œ ê¸°ì¡´ ì°¸ì—¬ìë“¤
    const otherUsers = roomUsers.filter(id => id !== socket.id)

    console.log('ğŸ”— ê¸°ì¡´ ì°¸ì—¬ìë“¤ê³¼ ì—°ê²°:', otherUsers)

    otherUsers.forEach(userId => {
      createOffer(userId)
    })
  }, [localStream, roomUsers.length])

  // ========================================
  // 6. í´ë¦°ì—…
  // ========================================
  useEffect(() => {
    return () => {
      // ëª¨ë“  PeerConnection ì¢…ë£Œ
      peerConnections.current.forEach(pc => pc.close())
      peerConnections.current.clear()

      // ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ì¤‘ì§€
      localStream?.getTracks().forEach(track => track.stop())
    }
  }, [])

  return {
    localStream,
    remoteStreams,
    localVideoRef,
    startLocalStream
  }
}
```

### 3-2. ë¹„ë””ì˜¤ ë£¸ ì»´í¬ë„ŒíŠ¸

```typescript
// src/components/VideoRoom.tsx
import { useEffect } from 'react'
import { useWebRTC } from '@/hooks/useWebRTC'

interface VideoRoomProps {
  socket: Socket
  roomUsers: string[]
}

export function VideoRoom({ socket, roomUsers }: VideoRoomProps) {
  const {
    localStream,
    remoteStreams,
    localVideoRef,
    startLocalStream
  } = useWebRTC(socket, roomUsers)

  useEffect(() => {
    startLocalStream()
  }, [])

  return (
    <div>
      <h2>í™”ìƒ í†µí™”</h2>

      {/* ë¡œì»¬ ë¹„ë””ì˜¤ */}
      <div>
        <h3>ë‚˜</h3>
        <video
          ref={localVideoRef}
          autoPlay
          muted
          playsInline
          style={{ width: '300px', border: '2px solid blue' }}
        />
      </div>

      {/* ì›ê²© ë¹„ë””ì˜¤ë“¤ */}
      <div>
        <h3>ì°¸ì—¬ìë“¤ ({remoteStreams.size}ëª…)</h3>
        {Array.from(remoteStreams.entries()).map(([userId, stream]) => (
          <div key={userId}>
            <p>{userId}</p>
            <video
              autoPlay
              playsInline
              ref={(el) => {
                if (el) el.srcObject = stream
              }}
              style={{ width: '300px', border: '2px solid green' }}
            />
          </div>
        ))}
      </div>

      {remoteStreams.size === 0 && (
        <p>ë‹¤ë¥¸ ì°¸ì—¬ìë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
      )}
    </div>
  )
}
```

### 3-3. í†µí•© (ë°© í˜ì´ì§€ ìˆ˜ì •)

```typescript
// src/pages/RoomPage.tsx (ìˆ˜ì •)
import { VideoRoom } from '@/components/VideoRoom'

export default function RoomPage() {
  const { socket, isConnected } = useSocket()
  const { currentRoom, users, ... } = useRoom(socket)

  // ... ì´ì „ ì½”ë“œ ...

  if (currentRoom && socket) {
    return (
      <div>
        <h1>ë°©: {currentRoom}</h1>
        <button onClick={leaveRoom}>ë‚˜ê°€ê¸°</button>

        {/* âœ… WebRTC ì»´í¬ë„ŒíŠ¸ ì¶”ê°€ */}
        <VideoRoom socket={socket} roomUsers={users} />
      </div>
    )
  }

  // ... ì´ì „ ì½”ë“œ ...
}
```

---

## í•µì‹¬ í”Œë¡œìš° ì •ë¦¬

### ì‚¬ìš©ì Aê°€ ë°© ìƒì„± í›„ ëŒ€ê¸°

```
1. A: createRoom('room1')
2. A: startLocalStream() â†’ ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œ
3. A: ë¡œì»¬ ë¹„ë””ì˜¤ í‘œì‹œ
4. A: ëŒ€ê¸° ì¤‘...
```

### ì‚¬ìš©ì Bê°€ ì…ì¥

```
1. B: joinRoom('room1')
   â†’ ì„œë²„: existingUsers = [A]

2. B: startLocalStream()

3. B: createOffer(A) ì‹¤í–‰
   â†’ B: PeerConnection ìƒì„±
   â†’ B: createOffer()
   â†’ B: setLocalDescription(offer)
   â†’ B: socket.emit('offer', { target: A, offer })

4. ì„œë²„: Aì—ê²Œ offer ì¤‘ê³„

5. A: offer ìˆ˜ì‹ 
   â†’ A: PeerConnection ìƒì„±
   â†’ A: setRemoteDescription(offer)
   â†’ A: createAnswer()
   â†’ A: setLocalDescription(answer)
   â†’ A: socket.emit('answer', { target: B, answer })

6. ì„œë²„: Bì—ê²Œ answer ì¤‘ê³„

7. B: answer ìˆ˜ì‹ 
   â†’ B: setRemoteDescription(answer)

8. ì–‘ìª½ì—ì„œ ICE Candidate êµí™˜
   â†’ B: onicecandidate â†’ socket.emit('ice-candidate')
   â†’ A: ice-candidate ìˆ˜ì‹  â†’ addIceCandidate()
   â†’ A: onicecandidate â†’ socket.emit('ice-candidate')
   â†’ B: ice-candidate ìˆ˜ì‹  â†’ addIceCandidate()

9. P2P ì—°ê²° ì™„ë£Œ!
   â†’ A: ontrack â†’ Bì˜ ë¹„ë””ì˜¤ ìˆ˜ì‹ 
   â†’ B: ontrack â†’ Aì˜ ë¹„ë””ì˜¤ ìˆ˜ì‹ 
```

---

## íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ë¬¸ì œ 1: ë¹„ë””ì˜¤ê°€ ì•ˆ ë³´ì„

**ì›ì¸**:
- ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œ ê±°ë¶€
- HTTPS ì•„ë‹˜ (localhostëŠ” OK)

**í•´ê²°**:
```typescript
try {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true
  })
} catch (error) {
  console.error('ë¯¸ë””ì–´ ì ‘ê·¼ ì‹¤íŒ¨:', error)
  // ì‚¬ìš©ìì—ê²Œ ê¶Œí•œ ìš”ì²­ ì•ˆë‚´
}
```

### ë¬¸ì œ 2: ICE Candidate ì‹¤íŒ¨

**ì›ì¸**:
- STUN ì„œë²„ ì ‘ê·¼ ë¶ˆê°€
- ë°©í™”ë²½/NAT ì´ìŠˆ

**í•´ê²°**:
```typescript
const STUN_SERVERS = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    // TURN ì„œë²„ ì¶”ê°€ (NAT í†µê³¼ ì‹¤íŒ¨ ì‹œ)
    // { urls: 'turn:your-turn-server.com', username: 'user', credential: 'pass' }
  ]
}
```

### ë¬¸ì œ 3: ì–‘ìª½ì—ì„œ ë™ì‹œì— Offer

**ì›ì¸**:
- user-joined ì´ë²¤íŠ¸ë¥¼ ì–‘ìª½ ëª¨ë‘ ë°›ìŒ

**í•´ê²°**:
```typescript
socket.on('user-joined', ({ userId }) => {
  // ë³¸ì¸ IDê°€ ë” í° ìª½ë§Œ Offer ìƒì„±
  if (socket.id! > userId) {
    setTimeout(() => createOffer(userId), 1000)
  }
})
```

---

## ì²´í¬ë¦¬ìŠ¤íŠ¸

### Phase 1
- [ ] Socket.IO ì—°ê²° í™•ì¸
- [ ] ì„œë²„ ë¡œê·¸ í™•ì¸

### Phase 2
- [ ] ë°© ìƒì„± ì„±ê³µ
- [ ] ë°© ì…ì¥ ì„±ê³µ
- [ ] ê¸°ì¡´ ì°¸ì—¬ì ëª©ë¡ ìˆ˜ì‹ 
- [ ] user-joined ì´ë²¤íŠ¸ ìˆ˜ì‹ 

### Phase 3
- [ ] ë¡œì»¬ ë¹„ë””ì˜¤ í‘œì‹œ
- [ ] Offer/Answer êµí™˜ ë¡œê·¸
- [ ] ICE Candidate êµí™˜ ë¡œê·¸
- [ ] ì›ê²© ë¹„ë””ì˜¤ ìˆ˜ì‹ 
- [ ] P2P ì—°ê²° ì™„ë£Œ (connectionState: 'connected')

---

## ìµœì¢… êµ¬ì¡°

```
src/
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useSocket.ts       # Socket.IO ì—°ê²°
â”‚   â”œâ”€â”€ useRoom.ts         # ë°© ê´€ë¦¬
â”‚   â””â”€â”€ useWebRTC.ts       # WebRTC ë¡œì§
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ RoomList.tsx       # ë°© ëª©ë¡
â”‚   â”œâ”€â”€ CreateRoom.tsx     # ë°© ìƒì„±
â”‚   â””â”€â”€ VideoRoom.tsx      # ë¹„ë””ì˜¤ í†µí™”
â””â”€â”€ pages/
    â””â”€â”€ RoomPage.tsx       # ë©”ì¸ í˜ì´ì§€
```

**ì´ ë¼ì¸ ìˆ˜**: ~500ì¤„
**ê°œë°œ ì‹œê°„**: 12-15ì‹œê°„

---

**ë‹¤ìŒ ë‹¨ê³„**:
1. Phase 1ë¶€í„° ìˆœì„œëŒ€ë¡œ êµ¬í˜„
2. ê° ë‹¨ê³„ë§ˆë‹¤ í…ŒìŠ¤íŠ¸
3. ì½˜ì†” ë¡œê·¸ë¡œ ë””ë²„ê¹…
4. ì™„ì„± í›„ UI ê°œì„ 

í™”ì´íŒ…! ğŸš€
